var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A. Buffa and S. Christiansen. A Dual Finite Element Complex on the Barycentric Refinement. Mathematics of Computation 76, 1743–1769 (2007).\n\n\n\nJ.-C. Nédélec. Acoustic and Electromagnetic Equations. Applied Mathematical Sciences (Springer, 2001).\n\n\n\nS. Rao, D. Wilton and A. Glisson. Electromagnetic Scattering by Surfaces of Arbitrary Shape. IEEE Transactions on Antennas and Propagation 30, 409–418 (1982).\n\n\n\n","category":"page"},{"location":"apiref/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apiref/#BEAST.DoubleLayerRotatedMW3D","page":"API Reference","title":"BEAST.DoubleLayerRotatedMW3D","text":"struct DoubleLayerRotatedMW3D{T,K} <: MaxwellOperator3D{T,K}\n\nBilinear form given by:\n\n```math\n    α ∬_{Γ^2} k(x) ⋅ [n̂(x) × (∇G_γ(x-y) × j(y))]\n```\n\nwith ``G_γ = e^{-γ|x-y|} / 4π|x-y|``\n\nFields\n\nalpha::T: Factor in front of bilinear form.\ngamma::K: imaginary unit times the wavenumber.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.HH3DHyperSingularFDBIO","page":"API Reference","title":"BEAST.HH3DHyperSingularFDBIO","text":"∫_Γ dx ∫_Γ dy \\left(α G g(x) n_x ⋅ n_y f(y) + β G \\mbox{curl} g(x) ⋅ \\mbox{curl} f(y) \\right)\n\nwith G(xy) = frace^-γ x-y4 π x-y\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.HH3DLinearPotential","page":"API Reference","title":"BEAST.HH3DLinearPotential","text":"HH3DLinearPotential\n\nA potential that linearly increases in direction with scaling coefficient amplitude. Its negative gradient will be a uniform vector field pointing in the opposite direction.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.HH3DMonopole","page":"API Reference","title":"BEAST.HH3DMonopole","text":"HH3DMonopole\n\nPotential of a monopole-type point source (e.g., of an electric charge)\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.HH3DSingleLayerFDBIO","page":"API Reference","title":"BEAST.HH3DSingleLayerFDBIO","text":"a(uv) = α _ΓΓ u(x) G_γ(x-y) v(y)\n\nwith G_γ(r) = frace^-γr4πr.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.Identity","page":"API Reference","title":"BEAST.Identity","text":"Identity <: LocalOperator\n\nThe identity operator.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.LinearCombinationOfOperators","page":"API Reference","title":"BEAST.LinearCombinationOfOperators","text":"LinearCombinationOfOperators{T} <: AbstractOperator\n\nA linear combination of operators.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.MWDoubleLayerFarField3D-Tuple{}","page":"API Reference","title":"BEAST.MWDoubleLayerFarField3D","text":"MWDoubleLayerFarField3D(;gamma, amplitude)\n\nMaxwell double layer far-field operator for 3D.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.MWDoubleLayerField3D-Tuple{}","page":"API Reference","title":"BEAST.MWDoubleLayerField3D","text":"MWDoubleLayerField3D(; gamma, wavenumber)\n\nCreate the double layer near field operator, for use with potential.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.MWDoubleLayerRotatedFarField3D-Tuple{}","page":"API Reference","title":"BEAST.MWDoubleLayerRotatedFarField3D","text":"MWDoubleLayerRotatedFarField3D\n\nRotated Maxwell double layer far-field operator for 3D.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.MWFarField3D-Tuple{}","page":"API Reference","title":"BEAST.MWFarField3D","text":"MWFarField3D(;gamma, amplitude)\n\nMaxwell single layer far-field operator for 3D.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.MWFarField3DTD","page":"API Reference","title":"BEAST.MWFarField3DTD","text":"Operator to compute the far field of a current distribution in the time domain. In particular, given the current distribution j this operator allows for the computation of\n\nR =  x  y\nffd = n  _Γ j(r t - Rc dy\n\nwhere x is the unit vector in the direction of observation. Note that the assembly routing expects the observation directions to be normalised by the caller.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.MWSingleLayerField3D-Tuple{}","page":"API Reference","title":"BEAST.MWSingleLayerField3D","text":"MWSingleLayerField3D(;gamma, wavenumber, alpha, beta)\n\nCreate the single layer near field operator, for use with potential.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.NCross","page":"API Reference","title":"BEAST.NCross","text":"NCross <: LocalOperator\n\nThe identity operator where the trial function is rotated.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.NDRefSpace","page":"API Reference","title":"BEAST.NDRefSpace","text":"Local shape function r is the one whose field lines straddle local edge r, which is the edge adjacent to vertex r.\n\nThis is not the edge starting at vertex r. The downside of this local numbering scheme is that it cannot be extended to cells that are not simplices because there is no well defined concept of adjacent-ness.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.Operator","page":"API Reference","title":"BEAST.Operator","text":"Atomic operator: one that assemblechunk can deal with\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.RungeKuttaConvolutionQuadrature","page":"API Reference","title":"BEAST.RungeKuttaConvolutionQuadrature","text":"RungeKuttaConvolutionQuadrature{T,N,NN}\n\nT: the value type of the basis function. N: the number of stages. NN: N*N.\n\nPerforms a convolution quadrature on a laplaceKernel to represent an operator in time domain using an implicit Runge-Kutta method.\n\nlaplaceKernel: function of the Laplace variable s that returns an IntegralOperator. A, b: Coefficient matrix and vectors from the Butcher tableau. Δt: time step. zTransformedTermCount: Number of terms in the inverse Z-transform. contourRadius: radius of circle used as integration contour for the inverse Z-transform.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.SingleLayerTrace","page":"API Reference","title":"BEAST.SingleLayerTrace","text":"Describe a single layer operator from the surface to a line.\n\nv Su = _γ dx v(x) _Γ dy \frace^-ikR4πR u(y)\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.StagedTimeStep","page":"API Reference","title":"BEAST.StagedTimeStep","text":"StagedTimeStep{T,N,NN}\n\nT: the value type of the basis function. N: the number of stages. NN: the number of stages squared Each time step has intermediary stages given by the vertor c in a Butcher tableau (A,b,c)\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.TimeBasisDeltaShifted","page":"API Reference","title":"BEAST.TimeBasisDeltaShifted","text":"TimeBasisDeltaShifted{T}\n\nRepresents a TimeBasisDelta{T} retarded by a fraction of the time step.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.TimeBasisFunction","page":"API Reference","title":"BEAST.TimeBasisFunction","text":"TimeBasisFunction{N,D}\n\nT: the value type of the time basis function N: the number of intervals in the support (this included the semi infinite interval     stretching to +∞) D1: the degree of the TBF restricted to each of the intervals plus one\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.VIEFarField3D","page":"API Reference","title":"BEAST.VIEFarField3D","text":"Operator to compute the far field of a current distribution. In particular, given the current distribution j this operator allows for the computation of\n\nA j = n  _Ω j e^γ x  y dy\n\nwhere x is the unit vector in the direction of observation. Note that the assembly routing expects the observation directions to be normalised by the caller.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#BEAST.assemble-Tuple{BEAST.AbstractOperator, Any, Any}","page":"API Reference","title":"BEAST.assemble","text":"assemble(operator, test_functions, trial_functions;\n    storage_policy = Val{:bandedstorage},\n    threading = Threading{:multi},\n    quadstrat=defaultquadstrat(operator, test_functions, trial_functions))\n\nAssemble the system matrix corresponding to the operator operator tested with the test functions test_functions and the trial functions trial_functions.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.assemble-Tuple{BEAST.Functional, Any}","page":"API Reference","title":"BEAST.assemble","text":"assemble(fn, tfs)\n\nAssemble the vector of test coefficients corresponding to functional fn and test functions tfs.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.assemble_local_mixed!-Union{Tuple{T}, Tuple{BEAST.LocalOperator, BEAST.Space{T}, BEAST.Space{T}, Any}} where T","page":"API Reference","title":"BEAST.assemble_local_mixed!","text":"assemble_local_mixed(biop::LocalOperator, tfs, bfs)\n\nFor use when basis and test functions are defined on different meshes\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.assemblechunk!-Tuple{BEAST.IntegralOperator, BEAST.Space, BEAST.Space, Any}","page":"API Reference","title":"BEAST.assemblechunk!","text":"assemblechunk!(biop::IntegralOperator, tfs, bfs, store)\n\nComputes the matrix of operator biop wrt the finite element spaces tfs and bfs\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.assemblydata-Tuple{BEAST.Space}","page":"API Reference","title":"BEAST.assemblydata","text":"charts, admap, act_to_global = assemblydata(basis; onlyactives=true)\n\nGiven a basis this function returns a data structure containing the information required for matrix assemble, that is, the vector charts containing Simplex elements, a variable admap of type AssemblyData, and a mapping from indices of actively used simplices to global simplices.\n\nWhen onlyactives is true, another layer of indices is introduced to filter out all cells of the mesh that are not in the union of the support of the basis functions (i.e., when the basis functions are defined only on a part of the mesh).\n\nadmap is, in essence, a three-dimensional array of named tuples, which, by wrapping it in the struct AssemblyData, allows the definition of iterators. The tuple consists of the two entries\n\nadmap[i,r,c].globalindex\nadmap[i,r,c].coefficient\n\nHere, c and r are indices in the iterable set of (active) simplices and the set of shape functions on each cell/simplex: r ranges from 1 to the number of shape functions on a cell/simplex, c ranges from 1 to the number of active simplices, and i ranges from 1 to the number of maximal number of basis functions, where any of the shape functions contributes to. \n\nFor example, for continuous piecewise linear lagrange functions (c0d1), each of the three shape functions on a triangle are associated with exactly one Lagrange function, and therefore i is limited to 1.\n\nNote: When onlyactives=false, the indices c correspond to the position of the corresponding cell/simplex whilst iterating over geometry(basis). When onlyactives=true, then act_to_global(c) correspond to the position of the corresponding cell/simplex whilst iterating over geometry(basis).\n\nFor a triplet (i,r,c), globalindex is the index in the basis of the ith basis function that has a contribution from shape function r on (active) cell/simplex c. coefficient is the coefficient of that contribution in the linear combination defining that basis function in terms of shape function.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.basisfunction-Tuple{BEAST.Space, Any}","page":"API Reference","title":"BEAST.basisfunction","text":"basisfunction(basis, i)\n\nReturns a vector of the shape functions defining the ith function of the basis.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.blockassembler","page":"API Reference","title":"BEAST.blockassembler","text":"blockassembler(operator, test_space, trial_space) -> assembler\n\nReturn a callable object for the creation of blocks within a BEM matrix.\n\nThis function performs all tasks common to the assembly of several blocks within a single boundary element matrix. The return value can be used to generate blocks by calling it as follows:\n\nassembler(I,J,storefn)\n\nwhere I and J are arrays of indices in test_space and trial_space, respectively, corresponding to the rows and columns of the desired block.\n\nNote that the block will be constructed in compressed form, i.e. the rows and columns of the store that are written into are the positions within I and J (as opposed to the positions within 1:numfunctions(test_space) and 1:numfunctions(trial_space)). In particular the size of the constructed block will be (length(I), length(J)).\n\nThis last property allows the assembly of permutations of the BEM matrix by supplying for I and J permutations of 1:numfunctions(test_space) and 1:numfunctions(trial_space).\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BEAST.buffachristiansen","page":"API Reference","title":"BEAST.buffachristiansen","text":"buffachristiansen(Γ, γ)\n\nConstruct the set of Buffa-Christiansen functions subject to mesh Γ and only enforcing zero normal components on ∂Γ ∖ γ.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BEAST.buildhalfbc-NTuple{6, Any}","page":"API Reference","title":"BEAST.buildhalfbc","text":"buildhalfbc(fine, supp::Array{SVector{3,Int},1}, v, p)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.butcher_tableau_radau_2stages-Tuple{}","page":"API Reference","title":"BEAST.butcher_tableau_radau_2stages","text":"butcher_tableau_radau_2stages()\n\nReturns (A,b,c) corresponding to the Butcher tableau for the 2 stage Radau IIA scheme.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.butcher_tableau_radau_3stages-Tuple{}","page":"API Reference","title":"BEAST.butcher_tableau_radau_3stages","text":"butcher_tableau_radau_3stages()\n\nReturns (A,b,c) corresponding to the Butcher tableau for the 3 stage Radau IIA scheme.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.curl-Tuple{BEAST.Space}","page":"API Reference","title":"BEAST.curl","text":"curl(X)\n\nCompute the curl of a finite element basis. The resulting set of functions might be linearly dependent because of the kernel of the curl operator.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.dipolemw3d-Tuple{}","page":"API Reference","title":"BEAST.dipolemw3d","text":"dipolemw3d(;location, orientation, wavenumber)\n\nCreate an electric dipole solution to Maxwell's equations representing the electric field part. Implementation is based on (9.18) of Jackson's “Classical electrodynamics”, with the notable difference that the xp(ikr) is used.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.divergence-Tuple{BEAST.Space}","page":"API Reference","title":"BEAST.divergence","text":"divergence(x)\n\nCompute the divergence of a finite element space.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.duallagrangec0d1-Tuple{Any, Any, Any, Type{Val{2}}}","page":"API Reference","title":"BEAST.duallagrangec0d1","text":"duallagrangec0d1(originalmesh, refinedmesh)\n\nIt is the user responsibility to provide two meshes representing the same object. The second mesh needs to be obtained using \"barycentric_refinement(originalmesh)\". This basis function creats the dual Lagrange basis function and return an object that contains array of shapes [fns] It also return a gemoetry containing the refined mesh.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.duallagrangecxd0","page":"API Reference","title":"BEAST.duallagrangecxd0","text":"duallagrangecxd0(mesh, jct) -> basis\n\nBuild dual Lagrange piecewise constant elements. Boundary nodes are only considered if they are in the interior of jct.\n\nThe default dual function (interpolatory=false) is similar to the one depicted in Figure 3 of  Buffa et al (doi: 10.1090/S0025-5718-07-01965-5), with the difference that each individual shape function is normalized with respect to  the area so that overall the integral over the dual function is one.\n\nWhen interpolatory=true is used, the function value is one on the support, and thus, it gives rise to a partition of unity.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BEAST.elements-Tuple{Any}","page":"API Reference","title":"BEAST.elements","text":"elements(geo)\n\nCreate an iterable collection of the elements stored in geo. The order in which this collection produces the elements determines the index used for lookup in the data structures returned by assemblydata and quaddata.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.facecurrents-Tuple{Any, Any}","page":"API Reference","title":"BEAST.facecurrents","text":"fcr, geo = facecurrents(coeffs, basis)\n\nCompute the value of the function with the given collection of coeffient in the provided basis in all the centroids of the mesh underlying the basis. The mesh is returned together with the currents.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.gamma_wavenumber_handler-Tuple{Any, Any}","page":"API Reference","title":"BEAST.gamma_wavenumber_handler","text":"gamma_wavenumber_handler(gamma, wavenumber)\n\nThis function handles the input of gamma and wavenumber. It throws an error if both gamma and wavenumber are provided. If neither is provided, it assumes a static problem and returns Val(0) for gamma and wavenumber.\n\nArguments\n\ngamma: im * wavenumber or nothing.\nwavenumber: wavenumber or nothing.\n\nReturns\n\ngamma and wavenumber: Appropriate pair gamma and wavenumber.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.geometry-Tuple{BEAST.Space}","page":"API Reference","title":"BEAST.geometry","text":"geometry(basis)\n\nReturns an iterable collection of geometric elements on which the functions in basis are defined. The order the elements are encountered needs correspond to the element indices used in the data structure returned by assemblydata.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.getcommonedge-Tuple{Any, Any}","page":"API Reference","title":"BEAST.getcommonedge","text":"getcommonedge(cell1, cell2) -> e1, e2, edge\n\nReturns in edge the common vertices of cell1 and cell2. e1 contains the index of the vertex of cell1 opposite to this common edge, and with a plus or minus sign depending on whether the orientation of the common edge is along or against the internal orientation of cell1. Similar for e2.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.getindex_rtg-Tuple{BEAST.RTBasis}","page":"API Reference","title":"BEAST.getindex_rtg","text":"getindex_rtg(RT::RTBasis)\n\nReturns the indices of the global half RWGs present in RT. RT is typically gotten from rt_ports\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.grideval-Tuple{Any, Any, Any}","page":"API Reference","title":"BEAST.grideval","text":"grideval(points, coeffs, basis; type=nothing)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.index_actives-Tuple{Any, Any}","page":"API Reference","title":"BEAST.index_actives","text":"active, index_among_actives, num_active_cells, act_to_global =\n    index_actives(num_cells, celltonum)\n\nGiven the number of cells of the mesh num_cells and an array indicating, which shape functions of each cell are used in the definition of the basis, celltonum, index_actives(num_cells, celltonum) computes a Boolean vector active that indicates for each cell index if the cell is in the support of any basis function. For this reduced set of active cells, a new index set is introduced, where index_among_actives is a vector providing the mapping from the cells of the mesh to the indices of the active cells, num_active_cells provides the number of all active cells, and act_to_global is a vector providing the mapping from the indices of the active cells to the indices of cells of the underlying mesh of the basis function spce.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.indices_splitfemglobal-Union{Tuple{BEAST.LinearCombinationOfAbstractMeshFunctions{T}}, Tuple{T}} where T","page":"API Reference","title":"BEAST.indices_splitfemglobal","text":"indices_splitfemglobal(lincombgfs)\n\nGiven a linear combination of FEMFunctions and/or GlobalFunctions, return the indices of the fem and the global functions\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.instantiate_charts-Tuple{Any, Any, Any}","page":"API Reference","title":"BEAST.instantiate_charts","text":"instantiate_charts(geo, num_active_cells, active)\n\nReturns a vector of all actively used simplices.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.interpolate-Tuple{RefSpace, Any, RefSpace, Any}","page":"API Reference","title":"BEAST.interpolate","text":"interpolate(interpolant::RefSpace, chart1, interpolee::RefSpace, chart2)\n\nComputes by interpolation approximations of the local shape functions for interpolee on chart2 in terms of the local shape functions for interpolant on chart1. The returned value is a matrix Q such that\n\nphi_i approx sum_j Q_ij psi_j\n\nwith phi_i the i-th local shape function for interpolee and psi_j the j-th local shape function for interpolant.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.inverse_z_transform-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractVector{T}}} where T","page":"API Reference","title":"BEAST.inverse_z_transform","text":"inverse_z_transform(k, rho, N, X)\n\nReturns the k-th term of the inverse z-transform. X is an array of the z-transform evaluated in the points z=rhoexp(2impin/N) for n in 0:(N-1).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.isstatic-Tuple{Any}","page":"API Reference","title":"BEAST.isstatic","text":"isstatic(gamma)\n\nThis function checks if the provided gamma value represents a static problem. It returns true if gamma is of type Val{0} indicating a static problem.\n\nArguments\n\ngamma: gamma value.\n\nReturns\n\nA boolean indicating whether the problem is static or not.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.lagdimension","page":"API Reference","title":"BEAST.lagdimension","text":"The dimension of the space of Lagrange shape functions of degree d over a simplex of dimension n is binom(n+d,d) == binom(n+d,n)\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BEAST.lagrangec0d1-Tuple{Any}","page":"API Reference","title":"BEAST.lagrangec0d1","text":"lagrangec0d1(mesh; dirichlet=[true|false]) -> basis\n\nBuild lagrangec0d1 elements, including (dirichlet=false) or excluding (dirichlet=true) those attached to boundary vertices.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.lagrangec0d1_dirichlet-Tuple{Any}","page":"API Reference","title":"BEAST.lagrangec0d1_dirichlet","text":"lagrangec0d1(mesh[, bnd])\n\nConstruct the basis of continuous, piecewise linear basis functions subordinate to mesh mesh. Basis functions are constructed at vertices in the interionr of the mesh and on the closure of 'bnd'. In particular, leaving out the second argument creates a finite element space subject to homogeneous Dirichlet boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.laplace_to_z-NTuple{6, Any}","page":"API Reference","title":"BEAST.laplace_to_z","text":"laplace_to_z(rho, n, N, dt, A, b)\n\nReturns the complex matrix valued Laplace variable s that correspond to the variable z = rhoexp(2impin/N) for a given Butcher tableau (A,b,c) and a time step dt.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.linearpotentialvie-Tuple{}","page":"API Reference","title":"BEAST.linearpotentialvie","text":"linearpotentialvie(;     direction    = error(\"missing argument direction\"),     amplitude    = 1,   )\n\nLinear potential for volume integral equations.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.localindices-Tuple{BEAST._LagrangeGlobalNodesDoFs, CompScienceMeshes.Simplex, Any, Any}","page":"API Reference","title":"BEAST.localindices","text":"localindices(dof, chart, i)\n\nReturns a vector of indices into the vector of local shape functions that correspond to global degrees of freedom supported on sub-entity i, where the type of entity (nodes, edge, face) is encoded in the type of 'dof'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.make_celltonum-NTuple{4, Any}","page":"API Reference","title":"BEAST.make_celltonum","text":"celltonum = make_celltonum(num_cells, num_refs, num_bfs, basis)\n\nComputes the array celltonum[c,r] that, given the index c of a cell of the mesh associated with the basis and the index r of the shape function in the refspace associated with basis, provides the number of basis functions where the rth shape function on cell c is used in their definition.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.marchonintime-NTuple{4, Any}","page":"API Reference","title":"BEAST.marchonintime","text":"marchonintime(W0,Z,B,I; convhist=false)\n\nSolve by marching-on-in-time the causal convolution problem defined by (W0,Z,B) up to timestep I. Here, Z is an array of order 3 that contains a discretisation of a time translation invariant retarded potential operator. W0 is the inverse of the slice Z[:,:,1].\n\nKeyword arguments:     - 'convhist': when true, return in addition to the space-time data for the     solution also the vector of convergence histories as returned each time step     by the supplied solver W0.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.momintegrals!-Tuple{Any, Any, Any, Any, Any, Any, BEAST.DoubleQuadRule}","page":"API Reference","title":"BEAST.momintegrals!","text":"momintegrals!(biop, tshs, bshs, tcell, bcell, interactions, strat)\n\nFunction for the computation of moment integrals using simple double quadrature.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.move_after!-NTuple{4, Any}","page":"API Reference","title":"BEAST.move_after!","text":"Move the s-th element right after the d-th\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.nedelec2","page":"API Reference","title":"BEAST.nedelec2","text":"nedelec2(mesh, edges)\n\nConstructs the 2nd degree Nedelec basis of the first kind i.e. H(curl).\n\nReturns an object of type 'ND2Basis'.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BEAST.ntrace-Tuple{BEAST.RTRefSpace, Any, Any, Any}","page":"API Reference","title":"BEAST.ntrace","text":"ntrace(refspace, element, localindex, face)\n\nCompute the normal trace of all local shape functions on elements belonging to refspace on face. This function returns a matrix expressing the traces of local shape functions in refspace as linear combinations of functions in the local trace space. Cf. restrict. localindex is the index of face in the enumeration of faces of elements. In many special cases knowing this index allows for highly optimised implementations.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.ntrace-Union{Tuple{T}, Tuple{BEAST.DirectProductSpace{T}, Any}} where T","page":"API Reference","title":"BEAST.ntrace","text":"ntrace(X::Space, γ::Mesh)\n\nCompute the normal trace of basis X on mesh γ. γ is assumed to be part of the boundary of geometry(X).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.numfunctions-Tuple{BEAST.Space}","page":"API Reference","title":"BEAST.numfunctions","text":"numfunctions(basis)\n\nNumber of functions in the basis.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.planewave-NTuple{4, Any}","page":"API Reference","title":"BEAST.planewave","text":"planewave(polarisation,direction,amplitude,speedoflight)\n\nTime-domain plane wave.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.planewavemw3d-Tuple{}","page":"API Reference","title":"BEAST.planewavemw3d","text":"planewavemw3d(;direction, polarization, wavenumber, gamma[, amplitude=1])\n\nCreate a plane wave solution to Maxwell's equations.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.planewavevie-Tuple{}","page":"API Reference","title":"BEAST.planewavevie","text":"planewavevie(;       direction    = error(\"missing arguement direction\"),       polarization = error(\"missing arguement polarization\"),       wavenumber   = error(\"missing arguement wavenumber\"),       amplitude    = 1,       ) \n\nFor volume integral equations\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.portcells-Tuple{Any, Any}","page":"API Reference","title":"BEAST.portcells","text":"portcells(Γ::Mesh, γ::Mesh)\n\nreturns an array containing cell pairs of mesh Γ around a boundary edge that overlaps with mesh γ\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.potential-NTuple{4, Any}","page":"API Reference","title":"BEAST.potential","text":"potential(op, points, coeffs, basis)\n\nEvaluate operator for a given bases and expansion coefficients at the given points.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.qh-Union{Tuple{T}, Tuple{N}, Tuple{Type{T}, Any, Type{Val{N}}}} where {N, T}","page":"API Reference","title":"BEAST.qh","text":"Q = qd(T,dh,::Val{N})\n\nQ[k] is the factor in front resulting from differentiating t^(k-1) dh times.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.quaddata","page":"API Reference","title":"BEAST.quaddata","text":"quaddata(operator, test_refspace, trial_refspace, test_elements, trial_elements)\n\nReturns an object cashing data required for the computation of boundary element interactions. It is up to the client programmer to decide what (if any) data is cached. For double numberical quadrature, storing the integration points for example can significantly speed up matrix assembly.\n\noperator is an integration kernel.\ntest_refspace and trial_refspace are reference space objects. quadata\n\nis typically overloaded on the type of these local spaces of shape functions. (See the implementation in maxwell.jl for an example).\n\ntest_elements and trial_elements are iterable collections of the geometric\n\nelements on which the finite element space are defined. These are provided to allow computation of the actual integrations points - as opposed to only their coordinates.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BEAST.quadrule","page":"API Reference","title":"BEAST.quadrule","text":"quadrule(operator, test_refspace, trial_refspace, test_index, test_chart, trial_index, trial_chart, quad_data)\n\nBased on the operator kernel and the test and trial elements, this function builds an object whose type and data fields specify the quadrature rule that needs to be used to accurately compute the interaction integrals. The quad_data object created by quaddata is passed to allow reuse of any precomputed data such as quadrature points and weights, geometric quantities, etc.\n\nThe type of the returned quadrature rule will help in deciding which method of momintegrals to dispatch to.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BEAST.raviartthomas-Tuple{Any}","page":"API Reference","title":"BEAST.raviartthomas","text":"raviartthomas(mesh)\n\nConducts pre-processing on the input mesh by extracting the cell edges, cell pairs     and indices required to construct the RT basis on the mesh.\n\nCalls raviartthomas(mesh::Mesh, cellpairs::Array{Int,2}), which constructs     the RT basis on the mesh, using the cell pairs identified.\n\nReturns the RT basis object.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.raviartthomas-Union{Tuple{T}, Tuple{D1}, Tuple{U}, Tuple{CompScienceMeshes.AbstractMesh{U, D1, T}, Matrix{Int64}}} where {U, D1, T}","page":"API Reference","title":"BEAST.raviartthomas","text":"raviartthomas(mesh, cellpairs::Array{Int,2})\n\nConstructs the RT basis on the input mesh. The i-th RT basis function will     represent a current distribution flowing from cell cellpairs[1,i] to     cellpairs[2,i] on the mesh.\n\nReturns an object of type RTBasis, which comprises both the mesh and pairs of     Shape objects which corresponds to the cell pairs, containing the necsessary     coefficients and indices to compute the exact basis functions when required     by the solver.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.raviartthomas2-Tuple{Any}","page":"API Reference","title":"BEAST.raviartthomas2","text":"raviartthomas2(mesh)\n\nConducts pre-processing on the input mesh by extracting the cell edges, cell pairs     and indices required to construct the RT2 basis on the mesh.\n\nCalls raviartthomas2(mesh::Mesh, cellpairs::Array{Int,2}), which constructs     the RT2 basis on the mesh, using the cell pairs identified.\n\nReturns the RT2 basis object.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.raviartthomas2-Union{Tuple{T}, Tuple{D1}, Tuple{U}, Tuple{CompScienceMeshes.AbstractMesh{U, D1, T}, Matrix{Int64}}} where {U, D1, T}","page":"API Reference","title":"BEAST.raviartthomas2","text":"raviartthomas2(mesh, cellpairs::Array{Int,2})\n\nConstructs the RT2 basis on the input mesh. The i-th RT2 basis function will     represent a current distribution flowing from cell cellpairs[1,i] to     cellpairs[2,i] on the mesh.\n\nReturns an object of type RT2Basis, which comprises both the mesh and pairs of     Shape objects which corresponds to the cell pairs, containing the necsessary     coefficients and indices to compute the exact basis functions when required     by the solver.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.real_inverse_z_transform-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractVector{T}}} where T","page":"API Reference","title":"BEAST.real_inverse_z_transform","text":"real_inverse_z_transform(k, rho, N, X)\n\nReturns the k-th term of the inverse z-transform. It is assumed that X[n+1] = conj(X[N-n]) for each n in 1:(N-1) so that Nmax = N/2+1 or (N+1)/2 (resp. if N%2==0 or N%2==1) terms are used in X X is an array of the z-transform evaluated in the points z=rhoexp(2impin/N) for n in 0:(Nmax-1).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.refspace","page":"API Reference","title":"BEAST.refspace","text":"refspace(basis)\n\nReturns the ReferenceSpace of local shape functions on which the basis is built.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BEAST.restrict","page":"API Reference","title":"BEAST.restrict","text":"restrict(refspace, element1, element2)\n\nComputes the restriction of a set of local shape functions on element1 as linear combinations of the set of local shape functions on element2. More precisely restrict returns an NxM matrix P such that the i-th local shape g_i function on element2 can be written as:\n\ng_i = sum_j=1^M P_ij f_j\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BEAST.rt_cedge-Tuple{Matrix{Int64}, Any}","page":"API Reference","title":"BEAST.rt_cedge","text":"rt_cedge(cps::Array{Int,2}, weight)\n\nComputes single basis function with equally distributed constant current leaving or entering port defined by cellpairs cps.  weight defines the total current over the port and its direction (+ve = out, -ve = in)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.rt_ports-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"BEAST.rt_ports","text":"rt_ports(Γ::Mesh, γ::Mesh ...)\n\nConstructs the RT space on Γ, relative to boundary pairs in γ. γ expects any number of pairs-of-ports as arguments and accepts tuples, arrays, vectors etc. e.g rt_ports(Γ, a, b ...); where a = [γ₁ γ₂], b = (γ₃,γ₄) etc. rt_ports with no pair of ports supplied i.e rt_ports(Γ) reduces to the raviartthomas(Γ) function. The RT space ensures current continuity in each pair of ports. i.e. current leaving mesh Γ through γ₁ is accounted for in γ₂.\n\nReturns the RT basis object.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.rt_vedge-Tuple{Matrix{Int64}, Any}","page":"API Reference","title":"BEAST.rt_vedge","text":"rt_vedge(cps::Array{Int,2}, weight)\n\nComputes n-1 basis function with oscillating current in(leaving and entering) pairs of half triangles defined over port specified by cellpairs cps. weight defines the magnitude of individual current in and out the half triangles, and it's polarity simply defines whether to start with in or out\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.scalartype","page":"API Reference","title":"BEAST.scalartype","text":"scalartype(x)\n\nThe scalar field over which the values of a global or local basis function, or an operator are defined. This should always be a scalar type, even if the basis or operator takes on values in a vector or tensor space. This data type is used to determine the eltype of assembled discrete operators.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BEAST.scalartype-Union{Tuple{RefSpace{T}}, Tuple{T}} where T","page":"API Reference","title":"BEAST.scalartype","text":"scalartype(s)\n\nThe scalar field over which the argument to a basis function or operator's integration kernel are defined. This is always a salar data type, even if the function or kernel is defined over a multi-dimensional space.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.singleduallagd0-Tuple{Any, Any, Any}","page":"API Reference","title":"BEAST.singleduallagd0","text":"singleduallagd0(fine, F, v; interpolatory=false)\n\nBuild a single dual constant Lagrange element a mesh fine. F contains the indices to cells in the support and v is the index in the vertex list of the defining vertex.\n\nThe default dual function (interpolatory=false) is similar to the one depicted in Figure 3 of  Buffa et al (doi: 10.1090/S0025-5718-07-01965-5), with the difference that each individual shape function is normalized with respect to the area so that overall the integral over the dual function is one.\n\nWhen interpolatory=true is used, the function value is one on the support, and thus, it gives rise to a partition of unity.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.solve-Tuple{Any}","page":"API Reference","title":"BEAST.solve","text":"Solves a variational equation by simply creating the full system matrix and calling a traditional lu decomposition.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.timebasisc0d1","page":"API Reference","title":"BEAST.timebasisc0d1","text":"timebasisc0d1(type, timestep, numfunctions)\n\nBuild the space of continuous, piecewise linear time basis functions. The DoFs are the time steps. numfunctions basis functions will be built in total.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BEAST.timebasiscxd0","page":"API Reference","title":"BEAST.timebasiscxd0","text":"timebasiscxd0(timestep, numfunctions, T::Type=Float64)\n\nCreate a temporal basis based on shifted copies of the nodal continuous, piecewise linear interpolant.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BEAST.timebasisspline2","page":"API Reference","title":"BEAST.timebasisspline2","text":"timebasisspline2(timestep, numfunctions, T::Type=Float64)\n\nCreate a temporal basis based on shifted copies of the quadratic spline. The spline is the convolution of a cxd0 and a c0d1 basis function.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#BEAST.ttrace-Tuple{BEAST.NDLCDRefSpace, Any, Any, Any}","page":"API Reference","title":"BEAST.ttrace","text":"Does not give the correct result for an imput basis with non-vanishing input basis on the boundary\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.unitfunctionc0d1-Tuple{Any}","page":"API Reference","title":"BEAST.unitfunctionc0d1","text":"unitfunctionc0d1(mesh)\n\nConstructs a constant function with value 1 on mesh consisting of linear shapes. For dirichlet=true goes to zero on the boundary.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.unitfunctioncxd0-Tuple{Any}","page":"API Reference","title":"BEAST.unitfunctioncxd0","text":"unitfunctioncxd0(mesh)\n\nConstructs a constant function with value 1 on mesh.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.@discretise-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"BEAST.@discretise","text":"discr(eq, pairs...)\n\nThis macro provides syntactical sugar for the definition of a discretisation of a varational formulation. Given a variational equation EQ: Find j ∈ X such that for all k ∈ Y a(k,j) = f(k) can be discretised by stating:\n\neq = @discretise EQ j∈X k∈Y\n\n\n\n\n\n","category":"macro"},{"location":"apiref/#BEAST.VIE.hhboundary-Tuple{}","page":"API Reference","title":"BEAST.VIE.hhboundary","text":"hhboundary(;gamma, alpha, tau) hhboundary(;wavenumber, alpha, tau)\n\nBilinear form given by:\n\n    α _ΩΩ n(x)  j(x) G_γ(xy) τ(y) (grad k(y))\n\nwith G_γ = e^-γx-y  4πx-y and  τ(y) contrast function and n(x) normal vector\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.VIE.hhvolume-Tuple{}","page":"API Reference","title":"BEAST.VIE.hhvolume","text":"hhvolume(;gamma, alpha, tau)\nhhvolume(;wavenumber, alpha, tau)\n\nBilinear form given by:\n\n    α _ΩΩ (grad j(x))  G_γ(xy)τ(y) (grad k(y))\n\nwith G_γ = e^-γx-y  4πx-y and  τ(y) contrast function\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.VIE.hhvolumegradG-Tuple{}","page":"API Reference","title":"BEAST.VIE.hhvolumegradG","text":"hhvolumegradG(;gamma, alpha, tau)\nhhvolumegradG(;wavenumber, alpha, tau)\n\nBilinear form given by:\n\n    α _ΩΩ j(x) grad_y(G_γ(xy)) τ(y)  (grad k(y))\n\nwith G_γ = e^-γx-y  4πx-y and  τ(y) constant function\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.VIE.hhvolumek0-Tuple{}","page":"API Reference","title":"BEAST.VIE.hhvolumek0","text":"hhvolumek0(;gamma, alpha, tau) hhvolumek0(;wavenumber, alpha, tau)\n\nBilinear form given by:\n\n    α _ΩΩ j(x) G_γ(xy)τ(y) k(y)\n\nwith G_γ = e^-γx-y  4πx-y and  τ(y) contrast function\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.Maxwell3D.doublelayer-Tuple{}","page":"API Reference","title":"BEAST.Maxwell3D.doublelayer","text":"doublelayer(;gamma)\ndoublelayer(;wavenumber)\n\nMaxwell double layer operator.\n\nEither gamma or the wavenumber must be provided. Optionally, also alpha can be provided.\n\nIf alpha is not provided explitly, it is set to α = 1.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.Maxwell3D.hypersingular-Tuple{}","page":"API Reference","title":"BEAST.Maxwell3D.hypersingular","text":"hypersingular(;wavenumber)\n\nHyper singular part of the Maxwell 3D single layer operator.\n\nβ = -1mathrmj k is set with the wavenumber k.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.Maxwell3D.planewave-Tuple{}","page":"API Reference","title":"BEAST.Maxwell3D.planewave","text":"planewave(;\n        direction    = error(\"missing arguement `direction`\"),\n        polarization = error(\"missing arguement `polarization`\"),\n        wavenumber   = error(\"missing arguement `wavenumber`\"),\n        amplitude    = one(real(typeof(wavenumber))))\n\nTime-harmonic plane wave.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.Maxwell3D.singlelayer-Tuple{}","page":"API Reference","title":"BEAST.Maxwell3D.singlelayer","text":"singlelayer(;gamma, alpha, beta)\nsinglelayer(;wavenumber, alpha, beta)\n\nMaxwell 3D single layer operator.\n\nEither gamma, or the wavenumber, or α and β must be provided.\n\nIf α and β are not provided explitly, they are set to α = -γ and β = -1γ with γ=mathrmj k.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.Maxwell3D.weaklysingular-Tuple{}","page":"API Reference","title":"BEAST.Maxwell3D.weaklysingular","text":"weaklysingular(;wavenumber)\n\nWeakly singular part of the Maxwell 3D single layer operator.\n\nα = -mathrmj k is set with the wavenumber k.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.Variational.HilbertVector-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"BEAST.Variational.HilbertVector","text":"call(u::HilbertVector, f, params...)\nu(f, params...)\n\nAdd another operation to the opstack of u.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.Variational.depthfirst-Tuple{Any}","page":"API Reference","title":"BEAST.Variational.depthfirst","text":"depthfirst(xp)\n\nReturns an iterator that visits all nodes in an Expr depth first. head and args are visited before the Expr they define.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.Variational.transposecalls!","page":"API Reference","title":"BEAST.Variational.transposecalls!","text":"transposecall!(xp, skip=[])\n\nGoes through the syntax tree and replace all function calls f(p1,p2,...,x) with x(f,p1,p2,...).\n\n\n\n\n\n","category":"function"},{"location":"apiref/#Base.:+-Tuple{BEAST.Variational.BilForm, BEAST.Variational.BilForm}","page":"API Reference","title":"Base.:+","text":"Add two BilForms together\n\n\n\n\n\n","category":"method"},{"location":"apiref/#Base.:==-Tuple{BEAST.Variational.BilForm, BEAST.Variational.LinForm}","page":"API Reference","title":"Base.:==","text":"==(lhs::BilForm, rhs::LinForm)\n\nBuild an equation from a left hand and right hand side\n\n\n\n\n\n","category":"method"},{"location":"apiref/#Base.getindex-Tuple{Any, BEAST.Variational.HilbertVector, BEAST.Variational.HilbertVector}","page":"API Reference","title":"Base.getindex","text":"getindex(A, v::HilbertVector, u::HilbertVector)\n\nCreate a BilForm corresponding to A[v,u]\n\n\n\n\n\n","category":"method"},{"location":"apiref/#Base.getindex-Tuple{Any, BEAST.Variational.HilbertVector}","page":"API Reference","title":"Base.getindex","text":"getindex(f, v::HilbertVector)\nf[v]\n\nReturn a LinForm corresponding to f[v]\n\n\n\n\n\n","category":"method"},{"location":"apiref/#BEAST.Variational.@varform-Tuple{Any}","page":"API Reference","title":"BEAST.Variational.@varform","text":"@varform <form-definition>\n\nThe Julia form compiler uses the Julia parser and meta-programming based traversal of the AST to create a structure containing all information required for the description of a variational formulation from an Expr that follows closely widespread mathematical convention.\n\nE.g:\n\nEFIE = @varform T[k,j] = e[k]\nMFIE = @varform 0.5*I[k,j] + K[k,j] = h[k]\nPMCH = @varform M[k,j] - η*T[k,m] + 1/η*T[l,j] + M[l,m] = e[k] + h[l]\n\n\n\n\n\n","category":"macro"},{"location":"excitations/planewave/#planewaveEx","page":"Plane Wave","title":"Plane Wave Excitation","text":"","category":"section"},{"location":"excitations/planewave/","page":"Plane Wave","title":"Plane Wave","text":"A plane wave can be used as excitation in time-harmonic and time-domain scenarios.","category":"page"},{"location":"excitations/planewave/","page":"Plane Wave","title":"Plane Wave","text":"","category":"page"},{"location":"excitations/planewave/#Time-Harmonic","page":"Plane Wave","title":"Time-Harmonic","text":"","category":"section"},{"location":"excitations/planewave/","page":"Plane Wave","title":"Plane Wave","text":"A time-harmonic plane wave with amplitude a, wave vector bm k = k hatbm k, and polarization hatbm p (vectors with a hat denote unit vectors) is defined by the field","category":"page"},{"location":"excitations/planewave/","page":"Plane Wave","title":"Plane Wave","text":"bm e_mathrmPW(bm x) = a hatbm p   mathrme^-mathrmj bm k cdot bm x  ","category":"page"},{"location":"excitations/planewave/","page":"Plane Wave","title":"Plane Wave","text":"where the polarization and wave vector are orthogonal, that is,","category":"page"},{"location":"excitations/planewave/","page":"Plane Wave","title":"Plane Wave","text":"bm k cdot hatbm p = 0","category":"page"},{"location":"excitations/planewave/","page":"Plane Wave","title":"Plane Wave","text":"holds.","category":"page"},{"location":"excitations/planewave/#API","page":"Plane Wave","title":"API","text":"","category":"section"},{"location":"excitations/planewave/","page":"Plane Wave","title":"Plane Wave","text":"warning: Warning\nThere are currently two APIs for the BEM plane wave. Fix in future.","category":"page"},{"location":"excitations/planewave/#BEAST.planewavemw3d","page":"Plane Wave","title":"BEAST.planewavemw3d","text":"planewavemw3d(;direction, polarization, wavenumber, gamma[, amplitude=1])\n\nCreate a plane wave solution to Maxwell's equations.\n\n\n\n\n\n","category":"function"},{"location":"excitations/planewave/#BEAST.Maxwell3D.planewave","page":"Plane Wave","title":"BEAST.Maxwell3D.planewave","text":"planewave(;\n        direction    = error(\"missing arguement `direction`\"),\n        polarization = error(\"missing arguement `polarization`\"),\n        wavenumber   = error(\"missing arguement `wavenumber`\"),\n        amplitude    = one(real(typeof(wavenumber))))\n\nTime-harmonic plane wave.\n\n\n\n\n\n","category":"function"},{"location":"excitations/planewave/#BEAST.planewavevie","page":"Plane Wave","title":"BEAST.planewavevie","text":"planewavevie(;       direction    = error(\"missing arguement direction\"),       polarization = error(\"missing arguement polarization\"),       wavenumber   = error(\"missing arguement wavenumber\"),       amplitude    = 1,       ) \n\nFor volume integral equations\n\n\n\n\n\n","category":"function"},{"location":"excitations/planewave/","page":"Plane Wave","title":"Plane Wave","text":"","category":"page"},{"location":"excitations/planewave/#Time-Domain","page":"Plane Wave","title":"Time-Domain","text":"","category":"section"},{"location":"excitations/planewave/","page":"Plane Wave","title":"Plane Wave","text":"A plane wave in the time-domain is defined as ...","category":"page"},{"location":"excitations/planewave/#API-2","page":"Plane Wave","title":"API","text":"","category":"section"},{"location":"excitations/planewave/","page":"Plane Wave","title":"Plane Wave","text":"Some more details would be helpful here.","category":"page"},{"location":"excitations/planewave/#BEAST.planewave","page":"Plane Wave","title":"BEAST.planewave","text":"planewave(polarisation,direction,amplitude,speedoflight)\n\nTime-domain plane wave.\n\n\n\n\n\n","category":"function"},{"location":"excitations/monopole/#monopoleRef","page":"Monopole","title":"Monopole Excitation","text":"","category":"section"},{"location":"excitations/monopole/","page":"Monopole","title":"Monopole","text":"Text","category":"page"},{"location":"excitations/monopole/#API","page":"Monopole","title":"API","text":"","category":"section"},{"location":"excitations/monopole/#BEAST.HH3DMonopole-excitations-monopole","page":"Monopole","title":"BEAST.HH3DMonopole","text":"HH3DMonopole\n\nPotential of a monopole-type point source (e.g., of an electric charge)\n\n\n\n\n\n","category":"type"},{"location":"manual/customexc/#Defining-Custom-Excitation","page":"Custom excitations","title":"Defining Custom Excitation","text":"","category":"section"},{"location":"manual/customexc/","page":"Custom excitations","title":"Custom excitations","text":"BEAST.jl aims to use your own fields as excitations as easy as possible. Specifying your own field can be done by defining a function of the Cartesian coordinates and supplementing this definition with a method of BEAST.scalartype to announce the scalar type of the value returned by the field evaluation. Scalar type is, as the name suggest, always a scalar type such as ComplexF64, even if the field is vector valued.","category":"page"},{"location":"manual/customexc/","page":"Custom excitations","title":"Custom excitations","text":"Upon supplying this data, the field function happily interacts with the rest of the BEAST.jl infrastructure. For example, taking the trace of the field is in no way different from doing so for the supplied exciations:","category":"page"},{"location":"manual/customexc/","page":"Custom excitations","title":"Custom excitations","text":"    using CompScienceMeshes\n\n    κ = 1.0\n\n    # Custom excitations can be defined as functions of a point in Cartesian space,\n    # complemented with a function specifying the return type.\n    E(x) = point(ComplexF64, 1.0, 1.0im, 0.0) * exp(-im*κ*x[3])\n    BEAST.scalartype(::typeof(E)) = ComplexF64\n\n    # Such a custom field plays nicely with the tangential trace\n    # operators defined as part of the BEAST framework\n    e = (n × E) × n\n\n    fn = joinpath(pathof(BEAST), \"../../examples/assets/sphere45.in\")\n    Γ = readmesh(fn)\n    RT = raviartthomas(Γ)\n\n    t = Maxwell3D.singlelayer(wavenumber=κ)\n\n    @hilbertspace j\n    @hilbertspace k\n\n    Txx = assemble(t[k,j], j∈RT, k∈RT)\n    ex = assemble(e[k], k∈RT)\n\n    iTXX = BEAST.GMRESSolver(Txx; maxiter=1000, reltol=1e-5)\n    uX = iTXX * ex","category":"page"},{"location":"contributing/#contribRef","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In order to contribute to this package directly create a pull request against the master branch. Before doing so please: ","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Follow the style of the surrounding code.\nSupplement the documentation.\nWrite tests and check that no errors occur.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Style","page":"Contributing","title":"Style","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For a consistent style the JuliaFormatter.jl package is used which enforces the style defined in the .JuliaFormatter.toml file. To follow this style simply run","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using JuliaFormatter\nformat(pkgdir(BEAST))","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nThat all files follow the JuliaFormatter style is tested during the unit tests. Hence, do not forget to execute the two lines above. Otherwise, the tests are likely to not pass.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Add documentation for any changes or new features following the style of the existing documentation. For more information you can have a look at the Documenter.jl documentation.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#tests","page":"Contributing","title":"Tests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Write tests for your code changes and verify that no errors occur, e.g., by running","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"BEAST\")","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For more detailed information on which parts are tested the coverage can be evaluated on your local machine, e.g., by","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"BEAST\"; coverage=true, julia_args=`--threads 4`)\n\n# determine coverage\nusing Coverage\nsrc_folder = pkgdir(BEAST) * \"/src\"\ncoverage   = process_folder(src_folder)\nLCOV.writefile(\"path-to-folder-you-like\" * \"BEAST.lcov.info\", coverage)\n\nclean_folder(src_folder) # delete .cov files\n\n# extract information about coverage\ncovered_lines, total_lines = get_summary(coverage)\n@info \"Current coverage:\\n$covered_lines of $total_lines lines ($(round(Int, covered_lines / total_lines * 100)) %)\"","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In Visual Studio Code the Coverage Gutters plugin can be used to visualize the tested lines of the code by inserting the path of the BEAST.lcov.info file in the settings.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nFrom Julia 1.11 onwards the the coverage can be displayed in Visual Studio Code directly, since the TestItemRunner.jl package is employed.","category":"page"},{"location":"manual/examplesTD/tdefie/#Solving-the-Time-Domain-EFIE-using-Marching-on-in-Time","page":"EFIE","title":"Solving the Time Domain EFIE using Marching-on-in-Time","text":"","category":"section"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"warning: Warning\nMake the following an @example which is actually executed.","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"If broadband information is required or if the system under study will be coupled to non-linear components, the scattering problem should be solved directly in the time domain, i.e. as a hyperbolic evolution problem.","category":"page"},{"location":"manual/examplesTD/tdefie/#Building-the-geometry","page":"EFIE","title":"Building the geometry","text":"","category":"section"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"Building the geometry and defining the spatial finite elements happens in completely the same manner as for frequency domain simulations:","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"using CompScienceMeshes\nusing BEAST\nD, dx = 1.0, 0.3\nΓ = meshsphere(1.0, dx)\nX = raviartthomas(Γ)\nnothing # hide","category":"page"},{"location":"manual/examplesTD/tdefie/#Basis-functions","page":"EFIE","title":"Basis functions","text":"","category":"section"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"Time domain currents are approximated in the tensor product of a spatial and temporal finite element space:","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"j(x) approx sum_i=1^N_T sum_m=1^N_S u_im T_i(t) f_m(x)","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"This package only supports translation invariant temopral basis functions, i.e.","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"T_i(t) = T(t - i Delta t)","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"where Delta t is the time step used to solve the problem. This time step depends on the bandwidth of the incident field and the desired accuracy. Space-Time Galerkin solvers of the type used here are not subject to stability conditions linking spatial and temporal discretisation resolutions.","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"We need a temporal trial space and test space. Common examples of temporal trial spaces are the shifted quadratic spline and shifted lagrange basis functions. In this example, a shifted quadratic spline S is used for the trial space, while a delta function U is used as the temporal test space to obtain a time-stepping solution.  ","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"Δt, Nt = 0.25, 300\nS = BEAST.timebasisspline2(Δt, Nt)\nU = BEAST.timebasisdelta(Δt, Nt)\nnothing # hide","category":"page"},{"location":"manual/examplesTD/tdefie/#Excitation","page":"EFIE","title":"Excitation","text":"","category":"section"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"We want to solve the EFIE, i.e. we want to find the current j such that","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"Tj = -e^i","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"where the incident electric field can be any Maxwell solution in the background medium. To describe this problem in Julia we create a retarded potential operator objects and a functional representing the incident field:","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"x = point(1.0,0.0,0.0)\ny = point(0.0,1.0,0.0)\nz = point(0.0,0.0,1.0)\ngaussian = BEAST.creategaussian(30Δt, 60Δt)\nE = BEAST.planewave(x, z, BEAST.derive(gaussian), 1.0)\nT = BEAST.MWSingleLayerTDIO(1.0,-1.0,-1.0,2,0)\nnothing; # hide","category":"page"},{"location":"manual/examplesTD/tdefie/#Setting-up-the-LSE","page":"EFIE","title":"Setting up the LSE","text":"","category":"section"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"Using the finite element spaces defined above this retarded potential equation can be discretized.","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"V = X ⊗ S #Space and time trial basis\nW = X ⊗ U #Space and time test basis\n\nB = assemble(E, W)\nZ = assemble(T, W, V)\nnothing # hide","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"The variable Z can efficiently store the matrices corresponding to different delays (assemble knows about the specific sparsity pattern of such matrices and returns a sparse array of rank three fit for purpose).","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"The algorithm below solves the discrete convolution problem by marching on in time:","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"Z0 = Z[:,:,1]\nW0 = inv(Z0)\nx = BEAST.marchonintime(W0,Z,-B,Nt)\nnothing # hide","category":"page"},{"location":"manual/examplesTD/tdefie/#Post-processing","page":"EFIE","title":"Post processing","text":"","category":"section"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"Computing the values of the induced current is now possible in the same manner as for frequency domain simulations by first converting our MOT solution back to the frequency domain using the fourier transform, along with some adjustments.","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"Xefie, Δω, ω0 = fouriertransform(x, Δt, 0.0, 2)\nω = collect(ω0 + (0:Nt-1)*Δω)\n_, i1 = findmin(abs(ω-1.0))\nω1 = ω[i1]\n\nue = Xefie[:,i1]\nue /= fouriertransform(gaussian)(ω1)\nfcr, geo = facecurrents(ue, X)\nnothing # hide","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"For now the package still relies upon Matlab for some of its visualisation. This dependency will be removed in the near future:","category":"page"},{"location":"manual/examplesTD/tdefie/","page":"EFIE","title":"EFIE","text":"include(Pkg.dir(\"CompScienceMeshes\",\"examples\",\"matlab_patches.jl\"))\nmat\"clf\"\npatch(geo, real.(norm.(fcr)))\nmat\"cd($(pwd()))\"\nmat\"print('current.png', '-dpng')\"","category":"page"},{"location":"excitations/linearpotential/#linpotRef","page":"Linear Potential","title":"Linear Potential Excitation","text":"","category":"section"},{"location":"excitations/linearpotential/","page":"Linear Potential","title":"Linear Potential","text":"Text","category":"page"},{"location":"excitations/linearpotential/#API","page":"Linear Potential","title":"API","text":"","category":"section"},{"location":"excitations/linearpotential/#BEAST.HH3DLinearPotential-excitations-linearpotential","page":"Linear Potential","title":"BEAST.HH3DLinearPotential","text":"HH3DLinearPotential\n\nA potential that linearly increases in direction with scaling coefficient amplitude. Its negative gradient will be a uniform vector field pointing in the opposite direction.\n\n\n\n\n\n","category":"type"},{"location":"excitations/linearpotential/#BEAST.linearpotentialvie-excitations-linearpotential","page":"Linear Potential","title":"BEAST.linearpotentialvie","text":"linearpotentialvie(;     direction    = error(\"missing argument direction\"),     amplitude    = 1,   )\n\nLinear potential for volume integral equations.\n\n\n\n\n\n","category":"function"},{"location":"operators/identity/#identityDef","page":"Identiy","title":"Identity Operator","text":"","category":"section"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"The identity operator is implemented in two flavors BEAST.Identity() and BEAST.NCross().","category":"page"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"","category":"page"},{"location":"operators/identity/#Definition","page":"Identiy","title":"Definition","text":"","category":"section"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"The identity operator","category":"page"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"bmmathcalI bm b = bm b","category":"page"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"returns the function it is provided unchanged.","category":"page"},{"location":"operators/identity/#As-bilinear-form","page":"Identiy","title":"As bilinear form","text":"","category":"section"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"When handed to the assemble function, the operator is interpreted as the bilinear form","category":"page"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"a(bm t bm b) = int_Gamma bm t(bm x)   bmmathcalI bm b(bm x) mathrmdbm x = int_Gamma bm t(bm x)   bm b(bm x) mathrmdbm x ","category":"page"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"Hence, the resulting matrix bm A contains the entries","category":"page"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"bm A_mn =  int_Gamma bm t_m(bm x)   bm b_n(bm x) mathrmdbm x ","category":"page"},{"location":"operators/identity/#API","page":"Identiy","title":"API","text":"","category":"section"},{"location":"operators/identity/#BEAST.Identity-operators-identity","page":"Identiy","title":"BEAST.Identity","text":"Identity <: LocalOperator\n\nThe identity operator.\n\n\n\n\n\n","category":"type"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"","category":"page"},{"location":"operators/identity/#Variant-with-\\bm-n-\\times","page":"Identiy","title":"Variant with bm n times","text":"","category":"section"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"As a variation, the identity operator is provided with a cross product with the normal vector bm n of the surface Gamma.","category":"page"},{"location":"operators/identity/#The-bilinear-form","page":"Identiy","title":"The bilinear form","text":"","category":"section"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"The assemble function, interprets the operator as the bilinear form","category":"page"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"a(bm t bm b) = int_Gamma bm t(bm x)   bmmathcalI (bm n(bm x) times bm b(bm x)) mathrmdbm x = int_Gamma bm t(bm x)   (bm n(bm x) times bm b(bm x)) mathrmdbm x ","category":"page"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"Hence, the resulting matrix bm A contains the entries","category":"page"},{"location":"operators/identity/","page":"Identiy","title":"Identiy","text":"bm A_mn =  int_Gamma bm t_m(bm x)   (bm n(bm x) times bm b_n(bm x)) mathrmdbm x ","category":"page"},{"location":"operators/identity/#API-2","page":"Identiy","title":"API","text":"","category":"section"},{"location":"operators/identity/#BEAST.NCross-operators-identity","page":"Identiy","title":"BEAST.NCross","text":"NCross <: LocalOperator\n\nThe identity operator where the trial function is rotated.\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#usageRef","page":"General Usage","title":"General Usage","text":"","category":"section"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"info: Info\nThe fundamental approach, which applies in most cases is:Define trial and test functions.\nDefine an operator and an excitation.\nAssemble the system matrix and the right-hand side","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"The available basis functions and corresponding geometry representations, available operators, and excitations are defined in the corresponding sections of this documentation.","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"","category":"page"},{"location":"manual/usage/#Introductory-Example:-EFIE","page":"General Usage","title":"Introductory Example: EFIE","text":"","category":"section"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"The fundamental procedure is exemplified for the electric field integral equation (EFIE); further common steps are discussed afterwards:","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"using CompScienceMeshes\nusing BEAST\n\n# --- 1. basis functions\nΓ  = meshsphere(radius=1.0, h=0.4)   # triangulate sphere of radius one\nRT = raviartthomas(Γ)                # define basis functions\n\n# --- 2. operators & excitation\n𝑇 = Maxwell3D.singlelayer(wavenumber=2.0)                             # integral operator\n𝐸 = Maxwell3D.planewave(direction=x̂, polarization=ẑ, wavenumber=2.0)  # excitation\n𝑒 = (n × 𝐸) × n # tangential part\n\n# --- 3. compute the RHS and system matrix\ne = assemble(𝑒, RT)         # assemble RHS\nT = assemble(𝑇, RT, RT)     # assemble system matrix\nnothing #hide","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"","category":"page"},{"location":"manual/usage/#Explanation","page":"General Usage","title":"Explanation","text":"","category":"section"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"The example follows the 3 steps. Specifically, in the example trial and test functions are the same (Raviart-Thomas), the excitation is a plane wave, and the operator is the Maxwell single layer operator.","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"tip: Tip\nThe assemble function is the key function of this package, it accepts either excitation + test function or operator + test + trial function.The operator can also be a linear combination of several operators.","category":"page"},{"location":"manual/usage/#BEAST.assemble","page":"General Usage","title":"BEAST.assemble","text":"assemble(operator, test_functions, trial_functions;\n    storage_policy = Val{:bandedstorage},\n    threading = Threading{:multi},\n    quadstrat=defaultquadstrat(operator, test_functions, trial_functions))\n\nAssemble the system matrix corresponding to the operator operator tested with the test functions test_functions and the trial functions trial_functions.\n\n\n\n\n\nassemble(fn, tfs)\n\nAssemble the vector of test coefficients corresponding to functional fn and test functions tfs.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"","category":"page"},{"location":"manual/usage/#Further-Common-Steps","page":"General Usage","title":"Further Common Steps","text":"","category":"section"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"The linear system of equations can now, for example, be solved via the iterative GMRES solver of the Krylov.jl package. However, other solver could be used. Subsequently, different post-processing steps can be conducted, such as computing the scattered field from the determined expansion coefficients.","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"tip: Tip\nKey functions for the post-processing are the potential and facecurrents functions.","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"This is shown in the following:","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"using Krylov, LinearAlgebra\n\n# --- solve linear system iteratively\nu, ch = Krylov.gmres(T, -e, rtol=1e-5)\n\nfcr, geo = facecurrents(u, RT)\npt = CompScienceMeshes.patch(Γ, norm.(fcr))\npl = PlotlyBase.Plot(pt)\nPlotlyDocumenter.to_documenter(pl) # hide","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"# --- post processing: compute scattered electric field at two Cartesian points\npoints = [[3.0, 4.0, 2.0], [3.0, 4.0, 3.0]]\nEF = potential(MWSingleLayerField3D(gamma=im*2.0), points, u, RT)","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"warning: Warning\nmore details","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"<figure>\n  <img\n    src=\"../../assets/currentREADME.png\"\n    alt=\"Setup\"\n    width=\"250\" />\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n  <img\n    src=\"../../assets/currentRealREADME.png\"\n    alt=\"Setup\"\n    width=\"250\" />\n</figure>\n<br/>","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"","category":"page"},{"location":"manual/usage/#Plotting-and-Exporting","page":"General Usage","title":"Plotting & Exporting","text":"","category":"section"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"Plotting details.","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"Export VTK.","category":"page"},{"location":"manual/usage/","page":"General Usage","title":"General Usage","text":"...","category":"page"},{"location":"operators/maxwelldoublelayer_td/#MWdoublelayerTDDef","page":"Time Domain","title":"Maxwell Double Layer Operator","text":"","category":"section"},{"location":"operators/maxwelldoublelayer_td/","page":"Time Domain","title":"Time Domain","text":"Text","category":"page"},{"location":"manual/examplesTH/efie/#Electric-Field-Integral-Equation","page":"EFIE","title":"Electric Field Integral Equation","text":"","category":"section"},{"location":"manual/examplesTH/efie/","page":"EFIE","title":"EFIE","text":"Text","category":"page"},{"location":"manual/examplesTH/efie/","page":"EFIE","title":"EFIE","text":"","category":"page"},{"location":"manual/examplesTH/efie/#Geometry","page":"EFIE","title":"Geometry","text":"","category":"section"},{"location":"manual/examplesTH/efie/","page":"EFIE","title":"EFIE","text":"Text","category":"page"},{"location":"manual/examplesTH/efie/","page":"EFIE","title":"EFIE","text":"...","category":"page"},{"location":"bases/buffachristiansen/#bcDef","page":"Buffa Christiansen","title":"Buffa Christiansen Basis Functions","text":"","category":"section"},{"location":"bases/buffachristiansen/","page":"Buffa Christiansen","title":"Buffa Christiansen","text":"Another citation [BC07]","category":"page"},{"location":"bases/buffachristiansen/","page":"Buffa Christiansen","title":"Buffa Christiansen","text":"","category":"page"},{"location":"bases/buffachristiansen/#First-Order","page":"Buffa Christiansen","title":"First Order","text":"","category":"section"},{"location":"bases/buffachristiansen/#BEAST.buffachristiansen","page":"Buffa Christiansen","title":"BEAST.buffachristiansen","text":"buffachristiansen(Γ, γ)\n\nConstruct the set of Buffa-Christiansen functions subject to mesh Γ and only enforcing zero normal components on ∂Γ ∖ γ.\n\n\n\n\n\n","category":"function"},{"location":"bases/buffachristiansen/#Triangles","page":"Buffa Christiansen","title":"Triangles","text":"","category":"section"},{"location":"bases/buffachristiansen/","page":"Buffa Christiansen","title":"Buffa Christiansen","text":"Some details.","category":"page"},{"location":"bases/buffachristiansen/#Quadrilaterals","page":"Buffa Christiansen","title":"Quadrilaterals","text":"","category":"section"},{"location":"bases/buffachristiansen/","page":"Buffa Christiansen","title":"Buffa Christiansen","text":"Not implemented yet.","category":"page"},{"location":"internals/assemble/#The-Matrix-Assemble-Routine","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"","category":"section"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"A lot of the design of this package derives from the need to express boundary element and finite element matrix assembly in a concise but general manner that is compatible with a wide range of linear and bilinear forms as encountered in the solution of variational problems.","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"In this section the matrix assembly routine at the center of this package will be discussed. As a case study we will go over the steps required to extend support for new kernels and new finite element spaces.","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"The matrix assemble routine is surprisingly short:","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"function assemblechunk!(biop::IntegralOperator, tfs::Space, bfs::Space, store)\n\n    test_elements, tad = assemblydata(tfs)\n    bsis_elements, bad = assemblydata(bfs)\n\n    tshapes = refspace(tfs); num_tshapes = numfunctions(tshapes)\n    bshapes = refspace(bfs); num_bshapes = numfunctions(bshapes)\n\n    T = promote_type(scalartype(biop), scalartype(tfs), scalartype(bfs))\n    zlocal = zeros(T, num_tshapes, num_bshapes)\n\n    qd = quaddata(biop, tshapes, bshapes, test_elements, bsis_elements)\n    for (p,tcell) in enumerate(test_elements), (q,bcell) in enumerate(bsis_elements)\n\n        fill!(zlocal, 0)\n        strat = quadrule(biop, tshapes, bshapes, p, tcell, q, bcell, qd)\n        momintegrals!(biop, tshapes, bshapes, tcell, bcell, zlocal, strat)\n\n        for j in 1 : num_bshapes, i in 1 : num_tshapes\n            z = zlocal[i,j]\n            for (m,a) in tad[p,i], (n,b) in bad[q,j]\n                store(a*z*b, m, n)\nend end end end","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Support for direct product spaces, linear combinations of kernels, non-standard storage of matrix elements, and parallel execution is provided by layers on top of this assembly routine. In this section we will focus on discussing the design and implementation of this inner building block that lies at the basis of more general functionality.","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Finite element spaces are usually stored as a collection of functions that in turn each comprise contributions from a limited number of geometric elements that make up the support of the function. In FEM and BEM matrix assembly, however, we need the tranposed information: given a geometric cell, and a local shape function, we need the ability to efficiently retrieve the list of basis functions whose definition contains the given local shape function on the given cell and the weight (aka coefficient) by which it contributes. The data structure that contains this information is referred to as the assembly data ad. In particular, ad[e,s], where e is the index of a geometric cell and s is the index of a local shape function, returns an iterable collection of pairs (m,w) where m is an index into the iterable collection of basis functions making up the finite element space and w is a weight, such that shape function s on geometric element e contributes with weight w to basis function n.","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"test_elements, tad = assemblydata(tfs)\nbsis_elements, bad = assemblydata(bfs)","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"One final note on the assemblydata function: as you can see from the above snippet, the function returns, in addition to the actual assembly data, an iterable collection of geometric elements. This collection is a subset of the collection of elements making up the geometry on which the finite element space is defined. The elements returned are those that actually appear in the domain of one or more of the functions that span the finite element space. The double for loop that iterates over pairs of trial and testing functions will only visit those used elements. Elements that are part of the geometry but do not appear as part of the support of a function are skipped. This behaviour is required to guarantee scalability when using multiple threads in assembling the matrix: each thread is assigned a subset of the basis functions; visiting unused elements in all threads is harmful for the overall efficiency.","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"With this assembly data in hand, matrix assembly can be done by iterating over geometric cells, rather than over basis functions. Doing this avoids visiting a given geometric cell more than once. When computing matrices resulting from discretisation with e.g. Raviart-Thomas elements, this can speed up assembly time with a factor 9.","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"The problem of matrix assembly is now reduced to the computation of interactions between local shape functions defined on all possible pairs of geometric cells. The space of local shape functions can be retrieved by calling","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"tshapes = refspace(tfs); num_tshapes = numfunctions(tshapes)\nbshapes = refspace(bfs); num_bshapes = numfunctions(bshapes)","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Here, num_tshapes and num_bshapes are the number of local shape functions. For example, when using Raviart-Thomas elements, the number of local shape functions equals three (one for every edge of the reference triangle).","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Based on this dimension, and based on the types used to represent numbers in the fields over which the spaces and the kernel are defined, the storage for local shape function interaction is pre-allocated:","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"T = promote_type(scalartype(biop), scalartype(tfs), scalartype(bfs))\nzlocal = zeros(T, num_tshapes, num_bshapes)","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Note that the computation of the storage type ensures that high precision or complex data types are only used when required. At all times the minimal storage type is selected. Not only does this keep memory use down, it also results in faster linear algebra computations such as matrix-vector multiplication.","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Before entering the double for loop that is responsible for the enumeration of all pairs of geometric cells (a trial cell pairs with a test cell), the implementer is given the opportunity to precompute data for use in the integration kernels. For example when using numerical quadrature rules to compute the double integral in the expression of the matrix entries, it is likely that a set of quadrature points for any given trial cells will be reused in interactions with a large number of test cells. To avoid computing these points and weights over and over, the client developer is given the opportunity to compute and store them by providing an appropriate method for quaddata . If memory use is more important the runtime, the client programmer is perfectly allowed to compute points and weights on the fly without storing them.","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"fill!(zlocal, 0)\nstrat = quadrule(biop, tshapes, bshapes, p, tcell, q, bcell, qd)\nmomintegrals!(biop, tshapes, bshapes, tcell, bcell, zlocal, strat)","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"For a given pair (tcell,bcell) of test cell and trial cell (with respective indices p and q in collections test_elements and bsis_elements), all possible interactions between local shape functions are computed. After resetting the buffer used to store these interactions, the quadrature strategy is determined. The quadrature strategy in general could depend on:","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"the kernel biop defining the integral operator,\nthe local test and trial shape functions tshapes and bshapes (functions of high polynomial degree and functions that are highly oscillatory typically require bespoke integration methods),\nand the geometric test and trial cells tcell and bcell (cells that touch or are near to each other lead to quickly varying or even singular integrands requiring dedicated integration rules).","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"The method returns an object strat that: (i) describes (by its type and its data fields) the integration strategy that is appropriate to compute the current set of local interactions, (ii) contains all data precomputed and stored in qd that is relevant to this particular integration (for example a set of quadrature points and weights). This explains why the indices p and q where passed too quadrule: they allow for the quick retrieval of relevant pre-stored data from qd.","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"The routing that is responsible for the actual computation of the interactions between the local shape functions takes the quadrule object strat as one of its arguments. The idea is that momintegrals! has many methods, not only for different types of kernel and shape functions, but also for different types of strat. For example, there are implementations of momintegrals! for the computation of the Maxwellian single layer operator w.r.t. spaces of Raviart-Thomas elements that employ double numerical quadrature, singularity extraction, and even more advanced integration routines.","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Note: the type of strat depends on the orientation of the two interacting geometric cells. This information is only available at runtime. In other words, there will be a slight type instability at this point in the code. This is by design however, and not different from the use of virtual functions in an c++ implementation. Numerical experiments show that this form of runtime polymorphism results in negligible runtime overhead.","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"When all possible interactions between local shape functions have been computed, they need to be stored in the global system matrix. This is done in the matrix assembly loop:","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"for j in 1 : num_bshapes\n    for i in 1 : num_tshapes\n        z = zlocal[i,j]\n        for (m,a) in tad[p,i]\n            for (n,b) in bad[q,j]\n                store(a*z*b, m, n)\n            end\n        end\n    end\nend","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"For both the test and trial local shape functions, the global indices at which they appear in the finite element space (and the corresponding weights) are retrieved from the assembly data objects. The contributing value v = a*z*b is constructed and its storage is delegated to the store method, which we received as one of the arguments passed to assemble_chunk!. In the simplest case, assemble_chunk! can be used like this:","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Z = zeros(ComplexF64, numfunctions(tfs), numfunctions(bfs))\nstore(v, m, n) = (Z[m,n] += v)\nassemble_chunk!(kernel, tfs, bfs, store)","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"In other words store will simply add the computed value to the specified entry in the global system matrix. Allowing the caller to specify store as an argument allows for more flexibility than hardcoding this behaviour in the assembly routine. Indeed, when computing blocks of a larger system, or when e.g. the transposed or a multiple of a given operator is desired, a fairly simple redefinition of store can provide this functionality. This is also the reason why assemble_chunk! ends in an exclamation mark: even though strictly speaking none of the arguments are modified, the function clearly has an effect on variables defined outside of its scope!","category":"page"},{"location":"internals/assemble/#Case-Study:-Implementation-of-the-Nitsche-Operator-Assembly","page":"The Matrix Assemble Routine","title":"Case Study: Implementation of the Nitsche Operator Assembly","text":"","category":"section"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"In the Nitsche method for the Maxwell system, penalty terms are added to the classic discretisation of the EFIE. When discretized using a non-conforming finite elements space (typically because the underlying geometric mesh is not conforming), the penalty term will force the solution to be divergence conforming in some weak sense. The penalty term derives from the following bilinear form:","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"p(vu) = int_gamma v(x) int_Γ frace^-ikx-y4πx-y u(y) dy dx","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Note that u(x) is supported by a 2D surface Γ whereas v(y) is supported by a 1D curve γ. The complete implementation of this operator could look like","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"mutable struct SingleLayerTrace{T} <: MaxwellOperator3D\n    gamma::T\nend\n\nfunction quaddata(operator::SingleLayerTrace,\n    localtestbasis::LagrangeRefSpace,  localtrialbasis::LagrangeRefSpace,\n    testelements,  trialelements)\n\n  tqd = quadpoints(localtestbasis,  testelements,  (10,))\n  bqd = quadpoints(localtrialbasis, trialelements, (8,))\n\n  return (tpoints=tqd, bpoints=bqd)\nend\n\nfunction quadrule(op::SingleLayerTrace, g::LagrangeRefSpace, f::LagrangeRefSpace, i, τ, j, σ, qd)\n    DoubleQuadRule(\n        qd.tpoints[1,i],\n        qd.bpoints[1,j]\n    )\nend\n\nintegrand(op::SingleLayerTrace, kernel, g, τ, f, σ) = f[1]*g[1]*kernel.green","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Every kernel corresponds with a type. Kernels can potentially depend on a set of parameters; these appear as fields in the type. Here our Nitsche kernel depends on the wavenumber. In quaddata we precompute quadrature points for all geometric cells in the supports of test and trial elements. This is fairly sloppy: only one rule for test and trial integration is considered. A high accuracy implementation would typically compute points for both low quality and high quality quadrature rules.","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"Also quadrule is sloppy: we always select a DoubleQuadRule to perform the computation of interactions between local shape functions. No singularity extraction or other advanced technique is considered for nearby interactions. Clearly amateurs at work here!","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"BEAST provides a default implementation of an integration routine using double numerical quadrature. All that is required to tap into that implementation is a method overloading integrand. From the above formula it is clear what this method should look like.","category":"page"},{"location":"internals/assemble/","page":"The Matrix Assemble Routine","title":"The Matrix Assemble Routine","text":"That's it!","category":"page"},{"location":"excitations/dipole/#dipoleRef","page":"Dipole","title":"Dipole Excitation","text":"","category":"section"},{"location":"excitations/dipole/","page":"Dipole","title":"Dipole","text":"A dipole ...","category":"page"},{"location":"excitations/dipole/","page":"Dipole","title":"Dipole","text":"","category":"page"},{"location":"excitations/dipole/#Time-Harmonic","page":"Dipole","title":"Time-Harmonic","text":"","category":"section"},{"location":"excitations/dipole/","page":"Dipole","title":"Dipole","text":"TODO","category":"page"},{"location":"excitations/dipole/#API","page":"Dipole","title":"API","text":"","category":"section"},{"location":"excitations/dipole/#BEAST.dipolemw3d","page":"Dipole","title":"BEAST.dipolemw3d","text":"dipolemw3d(;location, orientation, wavenumber)\n\nCreate an electric dipole solution to Maxwell's equations representing the electric field part. Implementation is based on (9.18) of Jackson's “Classical electrodynamics”, with the notable difference that the xp(ikr) is used.\n\n\n\n\n\n","category":"function"},{"location":"manual/quadrule/#Designing-your-own-quadrature-rule-and-strategy","page":"Custom Quadrature Rules","title":"Designing your own quadrature rule and strategy","text":"","category":"section"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"In the context of multi-trace solvers, testing and trial functions with logically separate but geometrically coinciding support can interact. In general these support can be equipped with completely indepenent meshes.","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"For meshes of flat faceted triangular panels, BEAST.jl defines the BEAST.NonConformingIntegralOpQStrat strategy. The constructor of NonConformingIntegralOpQStrat takes another quadratue strategy ctrat that is fit to deal with pairs of mutually conforming meshes of flat faceted meshes. For a pair comprising a test triangle and a trial triangle, the appropriate quadrature rule is chosen as follows:","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"If the triangles are well-separated, cstrat is run on the pair and the resulting quadrature strategy is chosen.\nIf the triangles have a single vertex in common, the Sauter-Schwab quadrature rule for common vertices is chosen.\nIf the triangles overlap or have edges that overlap, they are both refined so that a geometrically conforming mesh is obtained. For each pair of triangles in this refinement, cstrat is run and the resulting quadrature strategy is chosen.","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"This quadrature strategy is powerful but requires a lot of geometric processing, resulting in significant increases in matrix assembly times.","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"When the user has additional knowledge about the precise geometric constellation of the interacting meshes, a more economic approach can be desirable. It is of course the user's responsibility not to use this economic approach in a context where it is not applicable.","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"In this tutorial we assume that the test mesh is conforming to the barycentric refinement of the trial mesh. We propose a quadrature strategy NonConfTestBaryRefOfTrialQStrat, parametrised by an underlying quadrature strategy fit for mutually conforming meshes, that implements the following algorithm:","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"If the triangles are well-separated, cstrat is run on the pair and the resulting quadrature strategy is chosen.\nIf the test and trial triangle share a vertex, the barycentric refinement of the trial triangle is constructed and the decision on the quadrature rule is deferred to cstrat.","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"Because of the a priori knowledge about the relative constellation of the meshes, the construction in the second case will automatically result in a pair of mutually conforming meshes that can safely be send off to cstrat.","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"The first step in defining a new quadrature strategy is the definition of the corresponding type:","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"struct NonConfTestBaryRefOfTrialQStrat{P} <: BEAST.AbstractQuadStrat\n    conforming_qstrat::P\nend","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"The semantics of the quadrature strategy are captured by the definition of a pair of methods for the functions quaddata and quadrule, respectively. The purpose of quaddata is the computation of cache data that can speed up the assembly. Typically, this involves computing and storing triangle normals, and the quadrature points and weights for the various quadrature rules that the quadrature strategy considers.","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"Because in the majority of cases, the computation of the interaction is deferred to the conforming quadrature strategy, the computation of the cache is forwarded to its method of quaddata, resulting simply in:","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"function BEAST.quaddata(a, X, Y, test_charts, trial_charts, \n    quadstrat::NonConfTestBaryRefOfTrialQStrat)\n\n    return quaddata(a, X, Y, test_charts, trial_charts,\n        quadstrat.conforming_qstrat)\nend","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"The method of quadrule is key to the definition of the quadrature strategy and contains the the actual algorithm in charge of choosing the quadrature rule for any given pair of triangles:","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"function BEAST.quadrule(a, X, Y, i, test_chart, j, trial_chart, qd,\n    quadstrat::NonConfTestBaryRefOfTrialQStrat)\n\n    nh = BEAST._numhits(test_chart, trial_chart)\n    nh > 0 && return TestInBaryRefOfTrialQRule(quadstrat.conforming_qstrat)\n    return BEAST.quadrule(a, X, Y, i, test_chart, j, trial_chart, qd,\n        quadstrat.conforming_qstrat)\nend","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"The function body is essentially a one-to-one translation of the quadrature rule selection algorithm above to julia. The object qd passed to quadrule is the cache computed by quadrule. In our case, it is simply passed on to the underlying conforming quadrature rule in the case of well separated triangles.","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"Next, we define a type representing the quadrature rule that is used when test triangle and trial triangle are not well-separated:","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"struct TestInBaryRefOfTrialQRule{S}\n    conforming_qstrat::S\nend","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"The type TestInBaryRefOfTrialQRule refers to the quadrature rule that is responsible for the actual computation of the interactions in case of adjacency or overlap. Quadrature rules are implemented by specifying a method for the function BEAST.momintegrals!.","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"function BEAST.momintegrals!(out, op,\n    test_functions, test_cell, test_chart,\n    trial_functions, trial_cell, trial_chart,\n    qr::TestInBaryRefOfTrialQRule)\n\n    test_local_space = refspace(test_functions)\n    trial_local_space = refspace(trial_functions)\n\n    num_tshapes = numfunctions(test_local_space, domain(test_chart))\n    num_bshapes = numfunctions(trial_local_space, domain(trial_chart))\n\n    T = coordtype(test_chart)\n    z, u, h, t = zero(T), one(T), T(1//2), T(1//3)\n\n    c = CompScienceMeshes.point(T, t, t)\n    v = (\n        CompScienceMeshes.point(T, u, z),\n        CompScienceMeshes.point(T, z, u),\n        CompScienceMeshes.point(T, z, z))\n    e = (\n        CompScienceMeshes.point(T, z, h),\n        CompScienceMeshes.point(T, h, z),\n        CompScienceMeshes.point(T, h, h))\n\n    X = (\n        CompScienceMeshes.simplex(v[1], e[3], c),\n        CompScienceMeshes.simplex(v[2], c, e[3]),\n        CompScienceMeshes.simplex(v[2], e[1], c),\n        CompScienceMeshes.simplex(v[3], c, e[1]),\n        CompScienceMeshes.simplex(v[3], e[2], c),\n        CompScienceMeshes.simplex(v[1], c, e[2]))\n\n    C = CompScienceMeshes.cartesian(\n        CompScienceMeshes.neighborhood(trial_chart, c))\n    V = CompScienceMeshes.cartesian.((\n        CompScienceMeshes.neighborhood(trial_chart, v[1]),\n        CompScienceMeshes.neighborhood(trial_chart, v[2]),\n        CompScienceMeshes.neighborhood(trial_chart, v[3])))\n    E = CompScienceMeshes.cartesian.((\n        CompScienceMeshes.neighborhood(trial_chart, e[1]),\n        CompScienceMeshes.neighborhood(trial_chart, e[2]),\n        CompScienceMeshes.neighborhood(trial_chart, e[3])))\n\n    trial_charts = (\n        CompScienceMeshes.simplex(V[1], E[3], C),\n        CompScienceMeshes.simplex(V[2], C, E[3]),\n        CompScienceMeshes.simplex(V[2], E[1], C),\n        CompScienceMeshes.simplex(V[3], C, E[1]),\n        CompScienceMeshes.simplex(V[3], E[2], C),\n        CompScienceMeshes.simplex(V[1], C, E[2]))\n\n    quadstrat = qr.conforming_qstrat\n    qd = BEAST.quaddata(op, test_local_space, trial_local_space,\n        (test_chart,), trial_charts, quadstrat)\n\n    Q = zeros(T, num_tshapes, num_bshapes)\n    out1 = zero(out)\n    for (q,chart) in enumerate(trial_charts)\n        qr1 = BEAST.quadrule(op, test_local_space, trial_local_space,\n            1, test_chart, q ,chart, qd, quadstrat)\n            \n        BEAST.restrict!(Q, trial_local_space, trial_chart, chart, X[q])\n\n        fill!(out1, 0)\n        BEAST.momintegrals!(out1, op,\n            test_functions, nothing, test_chart,\n            trial_functions, nothing, chart, qr1)\n\n        for j in 1:num_bshapes\n            for i in 1:num_tshapes\n                for k in 1:size(Q, 2)\n                    out[i,j] += out1[i,k] * Q[j,k]\nend end end end end","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"The algorithm constructs the charts of the barycentric refinement of the trial chart, which either share a vertex or an edge with the test chart, or completely coincide with the test chart. Because of this, contributions from any of the refinement charts can be computed accuratey by a classic quadrature rule:","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"momintegrals!(outq, op,\n    test_functions, nothing, test_chart,\n    trial_functions, nothing, chart, qr)","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"This call to momintegrals! calculates interactions between the shape functions on the original test chart and the shape functions on one of the six subcharts in the refinement of the trial chart. The corresponding contribution to the interaction with the shape functions on the coarse trial chart can be calculated if we know how the restriction of the coarse shape functions to any of the subcharts can be written as linear combinations of the shape on that subchart. This information is provided by","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"BEAST.restrict!(Q, trial_local_space, trial_chart, chart, X[q])","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"For efficiency, the overlap function from the domain of chart to the domain of trial_chart has to be supplied.","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"note: Note\nThe quadrature strategy and related quadrature rules implemented here can be rearded as meta-strategies, and meta-rules, as they defer most of the heavy lifting to underlying strategies and rules for mutually conforming meshes.In a primitive rule, methods of momintegrals! typically contain implementations of numerical quadrature methods.","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"To verify correctness of the above strategy, we can compare the results against existing routines that either provide less accurate results or similar results at reduced efficiency.","category":"page"},{"location":"manual/quadrule/","page":"Custom Quadrature Rules","title":"Custom Quadrature Rules","text":"@testitem \"NonConfTestBaryRefOfTrialQStrat\" begin\n    using CompScienceMeshes\n\n    fnm = joinpath(dirname(pathof(BEAST)), \"../test/assets/sphere45.in\")\n    Γ1 = BEAST.readmesh(fnm)\n    Γ2 = deepcopy(Γ1)\n\n    X = raviartthomas(Γ1)\n    Y1 = buffachristiansen(Γ1)\n    Y = buffachristiansen(Γ2)\n\n    K = Maxwell3D.doublelayer(gamma=1.0)\n    qs1 = BEAST.DoubleNumWiltonSauterQStrat(2, 3, 6, 7, 5, 5, 4, 3)\n    qs2 = BEAST.NonConformingIntegralOpQStrat(qs1)\n    qs3 = BEAST.NonConfTestBaryRefOfTrialQStrat(qs1)\n\n    @time Kyx1 = assemble(K, Y, X; quadstrat=qs1)\n    @time Kyx2 = assemble(K, Y, X; quadstrat=qs2)\n    @time Kyx3 = assemble(K, Y, X; quadstrat=qs3)\n    @time Kyx4 = assemble(K, Y1, X; quadstrat=qs1)\n\n    using LinearAlgebra\n    @test norm(Kyx1 - Kyx2) < 0.05\n    @test norm(Kyx1 - Kyx3) < 0.05\n    @test norm(Kyx2 - Kyx3) < 0.002\n    @test norm(Kyx2 - Kyx4) < 0.002\n    @test norm(Kyx3 - Kyx4) < 1e-12\nend","category":"page"},{"location":"operators/maxwellsinglelayer/#MWsinglelayerDef","page":"Time Harmonic","title":"Maxwell Single Layer Operator","text":"","category":"section"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"The Maxwell single layer operator, also known als electric field integral operator (EFIO) is encountered in many time-harmonic BEM scattering formulations in electromagnetics. So far, only the 3D variant is implemented.","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"","category":"page"},{"location":"operators/maxwellsinglelayer/#Definition","page":"Time Harmonic","title":"Definition","text":"","category":"section"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"The operator is defined as (see, e.g., [RWG82])","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"bmmathcalT bm b = α bmmathcalT_s bm b + β bmmathcalT_h bm b","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"for a vector field bmb and parameters α and β, as well as, the weakly singular operator (also known as vector potential operator)","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"bmmathcalT_s bm b = int_Gamma g_γ(bm xbm y)  bm b(bm y) mathrmdbm y","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"and the hyper singular operator (also known as scalar potential operator)","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"bmmathcalT_h bm b = int_Gamma g_γ(bm xbm y)  _Γbm b(bm y) mathrmdbm y","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"with the free-space Green's function","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"g_γ(bm xbm y) = dfracmathrme^-γx-y4πx-y ","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"The parameters are typically α=-mathrmjk, β=-1(mathrmjk), and γ = mathrmjk with k denoting the wavenumber and mathrmj the imaginary unit.","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"","category":"page"},{"location":"operators/maxwellsinglelayer/#As-Bilinear-Form","page":"Time Harmonic","title":"As Bilinear Form","text":"","category":"section"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"When handed to the assemble function, the operators are interpreted as the corresponding bilinear forms","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"a(bm t bm b) = α _Gamma times Gamma bm t(bm x)  bm b(bm y)  g_γ(bm xbm y) mathrmdbm y mathrmdbm x + β _ΓΓ _Γbm t(bm x)   _Γbm b(bm y)  g_γ(bm xbm y) mathrmdbm y mathrmdbm x","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"for the complete Maxwell single layer operator,","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"a_s(bm t bm b) = α _Gamma times Gamma bm t(bm x)  bm b(bm y)  g_γ(bm xbm y) mathrmdbm y mathrmdbm x","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"for the weakly singular part, and","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"a_h(bm t bm b) = β _ΓΓ _Γbm t(bm x)   _Γbm b(bm y)  g_γ(bm xbm y) mathrmdbm y mathrmdbm x","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"for the hyper singular part. Note that the gradient in the hypersingular operator has been moved to the test function using, e.g., a Stokes identity [Ned01, p. 73].  The corresponding matrices contain the entries","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"bm A_mn =  a_x(bm t_m bm b_n) ","category":"page"},{"location":"operators/maxwellsinglelayer/#API","page":"Time Harmonic","title":"API","text":"","category":"section"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"The weakly singular and the hyper singular operator can be used as such or combined in the single layer operator.","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"tip: Tip\nThe qualifier Maxwell3D has to be used. ","category":"page"},{"location":"operators/maxwellsinglelayer/#BEAST.Maxwell3D.singlelayer","page":"Time Harmonic","title":"BEAST.Maxwell3D.singlelayer","text":"singlelayer(;gamma, alpha, beta)\nsinglelayer(;wavenumber, alpha, beta)\n\nMaxwell 3D single layer operator.\n\nEither gamma, or the wavenumber, or α and β must be provided.\n\nIf α and β are not provided explitly, they are set to α = -γ and β = -1γ with γ=mathrmj k.\n\n\n\n\n\n","category":"function"},{"location":"operators/maxwellsinglelayer/#BEAST.Maxwell3D.weaklysingular","page":"Time Harmonic","title":"BEAST.Maxwell3D.weaklysingular","text":"weaklysingular(;wavenumber)\n\nWeakly singular part of the Maxwell 3D single layer operator.\n\nα = -mathrmj k is set with the wavenumber k.\n\n\n\n\n\n","category":"function"},{"location":"operators/maxwellsinglelayer/#BEAST.Maxwell3D.hypersingular","page":"Time Harmonic","title":"BEAST.Maxwell3D.hypersingular","text":"hypersingular(;wavenumber)\n\nHyper singular part of the Maxwell 3D single layer operator.\n\nβ = -1mathrmj k is set with the wavenumber k.\n\n\n\n\n\n","category":"function"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"","category":"page"},{"location":"operators/maxwellsinglelayer/#As-Linear-Map","page":"Time Harmonic","title":"As Linear Map","text":"","category":"section"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"When handed to the potential function, the operator can be evaluated at provided points in space. Commonly, this is used in post-processing.","category":"page"},{"location":"operators/maxwellsinglelayer/#Far-Field","page":"Time Harmonic","title":"Far-Field","text":"","category":"section"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"In the limit that the observation point bm x rightarrow infty, the operator simplifies to the far-field (FF) version","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"(bmmathcalT_mathrmFF bm b)(bm x) = α  bmu_r times int_Gamma bmb(bm y) mathrme^mathrmjbmu_r cdot bmy mathrmdbmy times bmu_r ","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"where bmu_r is the unit vector in the direction of the evaluation point.","category":"page"},{"location":"operators/maxwellsinglelayer/#API-2","page":"Time Harmonic","title":"API","text":"","category":"section"},{"location":"operators/maxwellsinglelayer/#BEAST.MWSingleLayerField3D","page":"Time Harmonic","title":"BEAST.MWSingleLayerField3D","text":"MWSingleLayerField3D(;gamma, wavenumber, alpha, beta)\n\nCreate the single layer near field operator, for use with potential.\n\n\n\n\n\n","category":"type"},{"location":"operators/maxwellsinglelayer/#BEAST.MWFarField3D","page":"Time Harmonic","title":"BEAST.MWFarField3D","text":"MWFarField3D(;gamma, amplitude)\n\nMaxwell single layer far-field operator for 3D.\n\n\n\n\n\n","category":"type"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"tip: Tip\nThe provided points for the potential should be in Cartesian coordinates. The returned fields are also in Cartesian from.","category":"page"},{"location":"operators/maxwellsinglelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"warning: Warning\nSingularities are not addressed: the case when the evaluation point is close to the surface is not treated properly, so far.","category":"page"},{"location":"bases/overview/#basesRef","page":"Overview","title":"Bases Overview","text":"","category":"section"},{"location":"bases/overview/","page":"Overview","title":"Overview","text":"using TypeTree\nusing BEAST\n\nprint(join(tt(BEAST.Space), \"\"))","category":"page"},{"location":"bases/brezzidouglasmarini/#Title","page":"Brezzi-Douglas-Marini","title":"Title","text":"","category":"section"},{"location":"bases/gragliawiltonpeterson/#gwpRef","page":"Graglia-Wilton-Peterson","title":"Graglia-Wilton-Peterson","text":"","category":"section"},{"location":"bases/gragliawiltonpeterson/","page":"Graglia-Wilton-Peterson","title":"Graglia-Wilton-Peterson","text":"TODO","category":"page"},{"location":"manual/examplesTH/mfie/#Magnetic-Field-Integral-Equation","page":"MFIE","title":"Magnetic Field Integral Equation","text":"","category":"section"},{"location":"manual/examplesTH/mfie/","page":"MFIE","title":"MFIE","text":"TODO","category":"page"},{"location":"manual/quadstrat/#Customising-the-choice-of-quadrature-rules","page":"Setting the Quadrature Strategy","title":"Customising the choice of quadrature rules","text":"","category":"section"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"At the heart of any boundary element code are routines that can compute matrix entries that take on the form of double integrals over pairs of panels of an integrand that is the product of a test function, a trial function, and the fundamental solution of the equation under study. The fundamental solution is singular at the origin, implying that simple quadrature methods are not sufficient to compute the entries to satisfactory accuracy. A mechanism to activate the most appropriate rule is required. BEAST.jl attempts to offer a reasonable default, but the advanced user may wish to take control beyond this.","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"This page describes how the user can intervene in this system.","category":"page"},{"location":"manual/quadstrat/#List-of-implemented-quadrature-strategies","page":"Setting the Quadrature Strategy","title":"List of implemented quadrature strategies","text":"","category":"section"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"In BEAST, a clear distinction is made between a quadrature rule, which is a numerical algorithm that computes approximate values of a given integral with a given domain (a pair of panels in the case of BEM) and a given integral (comprising testing functions, trial functions, and a fundamental solution in the case of BEM). Different integrands and domains call for different quadrature rules. For a fixed integrand structure, the algorithm that chooses for any given constellation of panels the most appropriate rule is called the quadrature strategy.","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"The algorithm that determines which quadrature rule is used for any given geometric constellation of interacting panels is called the quadrature strategy. The list of strategies currently implemented in BEAST is:","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"using TypeTree\nusing BEAST\n\nprint(join(tt(BEAST.AbstractQuadStrat), \"\"))\nnothing # hide","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"The type of the quadrature strategy object determines the quadrature rule selection algorithm. The value of the fields contained by the quadrature strategy object typically selects the order or number of quadrature points used by the various possible quadrature rules.","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"The methods responsible for caching quadrature related data and quadrature rule selection are named quaddata and quadrule, respectively. For a given combination of a discrete boundary integral operator and quadrature strategy, the methods that will be dispatched to can be queried as follows:","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"using CompScienceMeshes\nusing BEAST\n\nΓ  = meshsphere(radius=1.0, h=0.45) # triangulate sphere of radius one\nRT = raviartthomas(Γ)\n𝑇 = Maxwell3D.singlelayer(wavenumber=2.0)\nqs = BEAST.DoubleNumWiltonSauterQStrat(6, 7, 7, 8, 6, 6, 6, 6)","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"BEAST.quadinfo(𝑇, RT, RT; quadstrat=qs)\nnothing # hide","category":"page"},{"location":"manual/quadstrat/#Explicitly-providing-the-quadrature-strategy","page":"Setting the Quadrature Strategy","title":"Explicitly providing the quadrature strategy","text":"","category":"section"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"The assembly function takes a keyword argument that allows to specify a specific quadrature strategy to use.","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"using CompScienceMeshes\nusing BEAST\n\nΓ  = meshsphere(radius=1.0, h=0.45)   # triangulate sphere of radius one\nRT = raviartthomas(Γ)\n𝑇 = Maxwell3D.singlelayer(wavenumber=2.0)\n\nZ1 = assemble(𝑇, RT, RT; quadstrat=BEAST.DoubleNumWiltonSauterQStrat(2, 3, 6, 7, 5, 5, 5, 5))\nZ2 = assemble(𝑇, RT, RT; quadstrat=BEAST.DoubleNumWiltonSauterQStrat(6, 7, 7, 8, 6, 6, 6, 6))\n\nusing LinearAlgebra\n2 * norm(Z1-Z2) / norm(Z1+Z2)","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"This method works well when only a single integral operator appears in the boundary integral equation. For systems containing multiple equations or when linear combinations of different operators appear, specifying a single quadrature strategy at the callsite of assemble will likely not be appropriate.","category":"page"},{"location":"manual/quadstrat/#Setting-the-default-quadrature-rule","page":"Setting the Quadrature Strategy","title":"Setting the default quadrature rule","text":"","category":"section"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"To query the set default quadrature strategy for a triple (op, testfns, trialfns),","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"using CompScienceMeshes\nusing BEAST\n\nΓ  = meshsphere(radius=1.0, h=0.45)   # triangulate sphere of radius one\nRT = raviartthomas(Γ)\n𝑇 = Maxwell3D.singlelayer(wavenumber=2.0)\n\nBEAST.defaultquadstrat(𝑇, RT, RT)","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"A new default can be set using the @defaultquadstrat macro. This creates a new method for the function defaultquadstrat that will be dispatched to for the arguments of the provided types.","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"BEAST.@defaultquadstrat (𝑇, RT, RT) BEAST.DoubleNumWiltonSauterQStrat(6, 7, 7, 8, 6, 6, 6, 6) \nZ2 = assemble(𝑇, RT, RT)\n\nBEAST.@defaultquadstrat (𝑇, RT, RT) BEAST.DoubleNumWiltonSauterQStrat(2, 3, 6, 7, 5, 5, 5, 5) \nZ1 = assemble(𝑇, RT, RT)\n\nusing LinearAlgebra\n2 * norm(Z1-Z2) / norm(Z1+Z2)","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"The above number provides some insight into the accuracy of the selected quadrature strategy. The advantage of setting the default quadrature strategy like this is that it is global and will automatically affect all subsequent calls to assembly. This means the set strategy will be used even if assembly is called as part of the assembly of a more complicated larger system, potentially containing linear combinations of integral operators.","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"The downside is that the default can only be set for concrete types of (op, testfns, trialfns) and that the call to the macro needs to be at Module scope. This makes it less appealing for complicated simulations and sweeps over the quadrature accuracy.","category":"page"},{"location":"manual/quadstrat/#Specifying-a-quadrature-strategy-selection-method","page":"Setting the Quadrature Strategy","title":"Specifying a quadrature strategy selection method","text":"","category":"section"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"This method is somehwat more involved, but is the most general and should allow for full control of the quadrature rules used in assembly.","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"function myquadstrat1(op, testfns, trialfns)\n    if op isa BEAST.MWSingleLayer3D\n        return BEAST.DoubleNumWiltonSauterQStrat(2, 3, 6, 7, 5, 5, 5, 5)\n    end\n    return BEAST.defaultquadstrat(op, testfns, trialfns)\nend\n\nfunction myquadstrat2(op, testfns, trialfns)\n    if op isa BEAST.MWSingleLayer3D\n        return BEAST.DoubleNumWiltonSauterQStrat(6, 7, 7, 8, 6, 6, 6, 6)\n    end\n    return BEAST.defaultquadstrat(op, testfns, trialfns)\nend\n\n\nZ1 = assemble(𝑇, RT, RT; quadstrat=myquadstrat1)\nZ3 = assemble(𝑇, RT, RT; quadstrat=myquadstrat2)\n2 * norm(Z1-Z2) / norm(Z1+Z2)","category":"page"},{"location":"manual/quadstrat/","page":"Setting the Quadrature Strategy","title":"Setting the Quadrature Strategy","text":"Best practice is too return BEAST.defaultquadstrat(op, testnfs, trialfns) by default to ensure that all operators are supported, also those for which no explicit overwrite is specified.","category":"page"},{"location":"bases/raviartthomas/#raviartthomasDef","page":"Raviart Thomas","title":"Raviart-Thomas Basis Functions","text":"","category":"section"},{"location":"bases/raviartthomas/","page":"Raviart Thomas","title":"Raviart Thomas","text":"Raviart-Thomas basis functions are also known as Rao-Wilton-Glisson functions [RWG82] and commonly employed for ...","category":"page"},{"location":"bases/raviartthomas/","page":"Raviart Thomas","title":"Raviart Thomas","text":"","category":"page"},{"location":"bases/raviartthomas/#First-Order","page":"Raviart Thomas","title":"First Order","text":"","category":"section"},{"location":"bases/raviartthomas/#BEAST.raviartthomas","page":"Raviart Thomas","title":"BEAST.raviartthomas","text":"raviartthomas(mesh, cellpairs::Array{Int,2})\n\nConstructs the RT basis on the input mesh. The i-th RT basis function will     represent a current distribution flowing from cell cellpairs[1,i] to     cellpairs[2,i] on the mesh.\n\nReturns an object of type RTBasis, which comprises both the mesh and pairs of     Shape objects which corresponds to the cell pairs, containing the necsessary     coefficients and indices to compute the exact basis functions when required     by the solver.\n\n\n\n\n\nraviartthomas(mesh)\n\nConducts pre-processing on the input mesh by extracting the cell edges, cell pairs     and indices required to construct the RT basis on the mesh.\n\nCalls raviartthomas(mesh::Mesh, cellpairs::Array{Int,2}), which constructs     the RT basis on the mesh, using the cell pairs identified.\n\nReturns the RT basis object.\n\n\n\n\n\n","category":"function"},{"location":"bases/raviartthomas/#Triangles","page":"Raviart Thomas","title":"Triangles","text":"","category":"section"},{"location":"bases/raviartthomas/","page":"Raviart Thomas","title":"Raviart Thomas","text":"Details on definition.","category":"page"},{"location":"bases/raviartthomas/#Quadrilaterals","page":"Raviart Thomas","title":"Quadrilaterals","text":"","category":"section"},{"location":"bases/raviartthomas/","page":"Raviart Thomas","title":"Raviart Thomas","text":"Details on definition.","category":"page"},{"location":"bases/raviartthomas/","page":"Raviart Thomas","title":"Raviart Thomas","text":"","category":"page"},{"location":"bases/raviartthomas/#Higher-Order","page":"Raviart Thomas","title":"Higher Order","text":"","category":"section"},{"location":"bases/raviartthomas/","page":"Raviart Thomas","title":"Raviart Thomas","text":"... same as GWP?","category":"page"},{"location":"geometry/flat/#Geometry","page":"Flat","title":"Geometry","text":"","category":"section"},{"location":"geometry/flat/","page":"Flat","title":"Flat","text":"using CompScienceMeshes\nΓ = meshsphere(radius=1.0, h=0.35)\npt = CompScienceMeshes.patch(Γ)\npl = PlotlyBase.Plot(pt)\nPlotlyDocumenter.to_documenter(pl) # hide","category":"page"},{"location":"internals/quadstrat/#Quadrature-strategies","page":"Quadrature","title":"Quadrature strategies","text":"","category":"section"},{"location":"internals/quadstrat/","page":"Quadrature","title":"Quadrature","text":"There are many ways to approximately compute the singular integrals that appear in boundary element discretisations of surface and volume integral euqations.","category":"page"},{"location":"internals/quadstrat/","page":"Quadrature","title":"Quadrature","text":"BEAST.jl is configured to select reasonable defaults, but advanced users may want to select their own quadrature rules. This section provides information on how to do this.","category":"page"},{"location":"internals/quadstrat/","page":"Quadrature","title":"Quadrature","text":"warning: Warning\nTODO: discuss directly available/implemented singularity treatment","category":"page"},{"location":"internals/quadstrat/#quaddata-and-quadrule","page":"Quadrature","title":"quaddata and quadrule","text":"","category":"section"},{"location":"internals/quadstrat/","page":"Quadrature","title":"Quadrature","text":"Numerical quadrature is governed by a pair of functions that need to be designed to work together:","category":"page"},{"location":"internals/quadstrat/","page":"Quadrature","title":"Quadrature","text":"quaddata: this function is executed before the assembly loop is entered. It's job is to compute all data needed for quadrature that the developer wants to be cached. Typically this is all geometric information such as the parametric and cartesian coordinates of all quadratures rules for all elemenents. It makes sense to cache this data as it will be used many times over in the double for loop that governs assembly. Typically, near singular interactions require more careful treatment than far interactions. This means that multiple quadrature rules per elements can be required. In such cases, the developer may want to opt to sture quadrature points and weights for all these rules. The function returns a quaddata object that holds all the cached data.\nquadrule: quadrule is executed inside the assembly hotloop. It receives a pair of elements and the quaddata object as its arguments. Based on this, the relevant cached data is extracted and stored in a quadrule object. The type of this object will determine the actual quadrature routined that will be called upon to do the numerical quadrature.","category":"page"},{"location":"internals/quadstrat/#quadstrat","page":"Quadrature","title":"quadstrat","text":"","category":"section"},{"location":"internals/quadstrat/","page":"Quadrature","title":"Quadrature","text":"The pair of quaddata and quadrule methods that is used is determined by the type of the operator and finite elements, and a quadstrat object. This object is passed to the assembly routine and passed on to quaddata and quadstrat, so it can be considered during dispatch.","category":"page"},{"location":"internals/quadstrat/","page":"Quadrature","title":"Quadrature","text":"Parameters, such as those that determine the accuracy of the numerical quadrature, are part of the runtime payload of the quadstrat object. This is usefull when the user is interested on the impact of these parameters on the performance and the accuracy of the solver without having to supply a new pair of quadstrat/quaddata methods for each possible value of these parameters.","category":"page"},{"location":"internals/quadstrat/","page":"Quadrature","title":"Quadrature","text":"Roughly this leads to the following (simplified) assembly routine:","category":"page"},{"location":"internals/quadstrat/","page":"Quadrature","title":"Quadrature","text":"function assemble(op, tfs, bfs, store; quadstrat=QS)\n\n    tad, tels = assemblydata(op, tfs)\n    bad, bels = assemblydata(op, bfs)\n    \n    qd = quadata(op,tels,bels,quadstrat)\n    for tel in tels\n        for bel in bels\n            qr = quadrule(op,tel,bel,qd,quadstrat)\n            zlocal = momintegrals(op,tel,bel,qr)\n\n            for i in axes(zlocal,1)\n                for j in axes(zlocal,2)\n                    m, a = tad[tel,i]\n                    n, b = bad[bel,j]\n                    store(a*zlocal[i,j]*b,m,n)\nend end end end end","category":"page"},{"location":"internals/quadstrat/","page":"Quadrature","title":"Quadrature","text":"It is conceivable that the types and functions described above look like this:","category":"page"},{"location":"internals/quadstrat/","page":"Quadrature","title":"Quadrature","text":"struct DoubleNumQS\n    test_precision\n    trial_precision\nend\n\nfunction quaddata(op, tels, bels, quadstrat::DoubleNumQS)\n    tqps = [quadpoints(tel,precision=quadstrat.test_precision) for tel in tels]\n    bqps = [quadpoints(bel,precision=quadstrat.basis_precision) for bel in bels]\n    return (test_quadpoints=tqps, basis_quadpoints=bqps)\nend\n\n\nstruct DoubleNumQR\n    test_quadpoints\n    trial_quadpoints\nend\n\nstruct HighPrecisionQR end\n\nfunction quadrule(op, tel, bel, qd, quadstrat::DoubleNumQs)\n    if wellseparated(tel, bel)\n        return DoubleNumQR(qd.test_quadpoints[tel], qd.basis_quadpoints[bel])\n    else\n        return HighPrecisionQR(tel, bel)\n    end\nend\n\nfunction momintegrals(op, tel, bel, qr::DoubleNumQR)\n    ...\nend\n\nfunction momintegrals(op, tel, bel, qr::HighPrecisionQR)\n    ...\nend","category":"page"},{"location":"manual/bilinear/#Systems-of-boundary-integral-equations-and-bilinear-forms","page":"System of Equations and Bilinear Forms","title":"Systems of boundary integral equations and bilinear forms","text":"","category":"section"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"For the most simple variational formulations such as the EFIE and MFIE, the boundary element matrices and right hand sided can be manually assembled.","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"For more complex formulations, such as those encountered in solving the transmission problem and in problems involving composite systems, this approach quickly becomes unwieldy. To facilitate the formulation and solution of these problems, BEAST.jl provides the ability to define quite general linear and bilinear forms.","category":"page"},{"location":"manual/bilinear/#The-single-body-transmission-problem","page":"System of Equations and Bilinear Forms","title":"The single body transmission problem","text":"","category":"section"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"THe transmission problem is defined by the material properties of the exterior and interior domain and the incident field:","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"using CompScienceMeshes\nusing BEAST\n\nκ1 = 1.0\nκ2 = 2.0\n\nE = Maxwell3D.planewave(direction=ẑ, polarization=x̂, wavenumber=κ1)\nH = -1/(im*κ1)*curl(E)\nnothing # hide","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"The PMCHWT can be used to model this transmission problem. To write down the variational formulation, pairs of placeholders for the trial functions and test functions are declared by the @hilbertspace macro.","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"T1  = Maxwell3D.singlelayer(wavenumber=κ1)\nK1  = Maxwell3D.doublelayer(wavenumber=κ1)\nT2  = Maxwell3D.singlelayer(wavenumber=κ2)\nK2  = Maxwell3D.doublelayer(wavenumber=κ2)\n\ne = (n × E) × n\nh = (n × H) × n\n\n@hilbertspace j m\n@hilbertspace k l\n\na =\n    (T1+T2)[k,j] + (-K1-K2)[k,m] +\n    (K1+K2)[l,j] + (T1+T2)[l,m]\nb =\n    -e[k] -h[l]","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"Note that we are able to define the formulation without specifying or constructing the mesh, the boundary element spaces, or the system matrices. The above constitutes a lazy representation of the formulation that takes neglible time to construct! ","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"Now this formulation is applied to a concrete geometry.","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"Γ = meshsphere(;radius=1.0, h=0.35)\nRT = raviartthomas(Γ)\n\nX = BEAST.DirectProductSpace([RT,RT])\n\nbx = assemble(b, X)\nAxx = assemble(a, X, X)","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"The type of Axx reveals that the structure of the underlying Hilbert space (with two generators in this case) is preserved. Also noteworthy is that only non-zero blocks in the system matrix are stored. This is important both for to limit memory consumption and to avoid unnecessary computations in performing the matrix-vector product.","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"BEAST.jl provides wrappers for iterative solvers that conform to the LinearMaps.jl interface. For example, SXX = GMRESSolver(Axx) acts like a LinearMap representing the inverse of Axx. Computing the action uX = SXX * bx runs the Krylov iterative process with right hand side bx and returns the solution to the linear system:","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"SXX = BEAST.GMRESSolver(Axx)\nuX = SXX * bx\ntypeof(uX)","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"The solution of this iterative process remembers its block structure. This makes it easy to select the electric and magnetic components:","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"import PlotlyBase\nimport PlotlyDocumenter # hide\nusing LinearAlgebra\n\nfcrm, geom = facecurrents(uX[m], RT)\nfcrj, geoj = facecurrents(uX[j], RT)\n\nptm = CompScienceMeshes.patch(geom, norm.(fcrm); caxis=(0,1.2) , showscale=false)\nptj= CompScienceMeshes.patch(geoj, norm.(fcrj); caxis=(0,1.2))\n\npl = [ PlotlyBase.Plot(ptm) PlotlyBase.Plot(ptj) ]\nPlotlyDocumenter.to_documenter(pl) # hide","category":"page"},{"location":"manual/bilinear/#Calderon-preconditioning-for-the-PMCHWT","page":"System of Equations and Bilinear Forms","title":"Calderon preconditioning for the PMCHWT","text":"","category":"section"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"Let's try to speed up convergence of the iterative solver by constructing a Calderon preconditioner. We opt for a block diagonal preconditioner containing only single layer contributions. The wavenumber used for construction of the preconditioner is purely imaginary to avoid the introduction of resonances.","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"Ty  = Maxwell3D.singlelayer(gamma=κ1)\n\nc = Ty[k,j] + Ty[l,m]","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"We also require discrete versions of the duality pairing to map primal test coefficients to dual expansion coefficients","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"Nx = BEAST.NCross()\nd = Nx[k,j] + Nx[l,m]","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"The corresponding block matrices can be built as before by appealing to the assemble function","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"BC = buffachristiansen(Γ)\nY = BEAST.DirectProductSpace([BC,BC])\n\nCyy = assemble(c, Y, Y)\nDxy = assemble(d, X, Y)","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"A lazy inverse for the discrete duality can be constructed by wrapping the block matrix in a Krylov solver object:","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"DYX = BEAST.GMRESSolver(Dxy, verbose=false)\nDXY = BEAST.GMRESSolver(Dxy', verbose=false)","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"We have now all the ingredients to write down the system we want to solve:","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"PAXx = DXY * Cyy * DYX * Axx\nPbX = DXY * Cyy * DYX * bx\n\nPSXx = BEAST.GMRESSolver(PAXx)\n\nu1, ch1 = solve(SXX, bx)\nu2, ch2 = solve(PSXx, PbX)\n\nusing LinearAlgebra\nnorm(u1-u2), ch1.iters, ch2.iters","category":"page"},{"location":"manual/bilinear/","page":"System of Equations and Bilinear Forms","title":"System of Equations and Bilinear Forms","text":"Even for this small example, the solution was reconstructed in a much smaller number of iterations. Because objects of type GMRESSolver effectively behave as the inverse of the wrapped LinearMap, an internal iterative solver to compute the action of the inverse of the duality pairing is triggered during each outer iteration without introducing notational overhead!","category":"page"},{"location":"operators/maxwellsinglelayerVIE/#MWsinglelayerVIEDef","page":"Maxwell Single Layer","title":"Maxwell Single Layer Operator","text":"","category":"section"},{"location":"operators/maxwellsinglelayerVIE/","page":"Maxwell Single Layer","title":"Maxwell Single Layer","text":"TODO","category":"page"},{"location":"operators/maxwelldoublelayer/#MWdoublelayerDef","page":"Time Harmonic","title":"Maxwell Double Layer Operator","text":"","category":"section"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"The Maxwell double layer operator is encountered in many time-harmonic BEM scattering formulations in electromagnetics. So far, only the 3D variant is implemented.","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"","category":"page"},{"location":"operators/maxwelldoublelayer/#Definition","page":"Time Harmonic","title":"Definition","text":"","category":"section"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"The operator is defined as (see, e.g., ...)","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"bmmathcalK bm b = α int_Gamma _x g_γ(bm xbm y) times bm b(bm y) mathrmdbm y","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"for a vector field bmb and a parameter α with the free-space Green's function","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"g_γ(bm xbm y) = dfracmathrme^-γx-y4πx-y ","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"The parameters are typically α=1 and γ = mathrmjk with k denoting the wavenumber and mathrmj the imaginary unit. As variation, the rotaded double layer operator","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"barbmmathcalK = bmn times bmmathcalK ","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"can be used which simply involves the cross product with the normal vector bmn of the surface Gamma.","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"","category":"page"},{"location":"operators/maxwelldoublelayer/#As-Bilinear-Form","page":"Time Harmonic","title":"As Bilinear Form","text":"","category":"section"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"When handed to the assemble function, the operators are interpreted as the corresponding bilinear forms","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"a(bm t bm b) = α _Gamma times Gamma bm t(bm x)   ( _x g_γ(bm xbm y) times bm b(bm y) ) mathrmdbm y mathrmdbm x","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"and","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"bara(bm t bm b) = α _Gamma times Gamma bm t(bm x)    (bmn times ( _x g_γ(bm xbm y) times bm b(bm y) )) mathrmdbm y mathrmdbm x","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"resulting in the matrix","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"bm A_mn =  a(bm t_m bm b_n) ","category":"page"},{"location":"operators/maxwelldoublelayer/#API","page":"Time Harmonic","title":"API","text":"","category":"section"},{"location":"operators/maxwelldoublelayer/#BEAST.Maxwell3D.doublelayer","page":"Time Harmonic","title":"BEAST.Maxwell3D.doublelayer","text":"doublelayer(;gamma)\ndoublelayer(;wavenumber)\n\nMaxwell double layer operator.\n\nEither gamma or the wavenumber must be provided. Optionally, also alpha can be provided.\n\nIf alpha is not provided explitly, it is set to α = 1.\n\n\n\n\n\n","category":"function"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"","category":"page"},{"location":"operators/maxwelldoublelayer/#As-Linear-Map","page":"Time Harmonic","title":"As Linear Map","text":"","category":"section"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"When handed to the potential function, the operator can be evaluated at provided points in space. Commonly, this is used in post-processing.","category":"page"},{"location":"operators/maxwelldoublelayer/#Far-Field","page":"Time Harmonic","title":"Far-Field","text":"","category":"section"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"In the limit that the observation point bm x rightarrow infty, the operator simplifies to the far-field (FF) version","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"(bmmathcalK_mathrmFF bm b)(bm x) = α bmu_r times int_Gamma bmb(bm y) mathrme^mathrmjbmu_r cdot bmy mathrmdbmy","category":"page"},{"location":"operators/maxwelldoublelayer/#API-2","page":"Time Harmonic","title":"API","text":"","category":"section"},{"location":"operators/maxwelldoublelayer/#BEAST.MWDoubleLayerField3D","page":"Time Harmonic","title":"BEAST.MWDoubleLayerField3D","text":"MWDoubleLayerField3D(; gamma, wavenumber)\n\nCreate the double layer near field operator, for use with potential.\n\n\n\n\n\n","category":"type"},{"location":"operators/maxwelldoublelayer/#BEAST.MWDoubleLayerFarField3D","page":"Time Harmonic","title":"BEAST.MWDoubleLayerFarField3D","text":"MWDoubleLayerFarField3D(;gamma, amplitude)\n\nMaxwell double layer far-field operator for 3D.\n\n\n\n\n\n","category":"type"},{"location":"operators/maxwelldoublelayer/#BEAST.MWDoubleLayerRotatedFarField3D","page":"Time Harmonic","title":"BEAST.MWDoubleLayerRotatedFarField3D","text":"MWDoubleLayerRotatedFarField3D\n\nRotated Maxwell double layer far-field operator for 3D.\n\n\n\n\n\n","category":"type"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"tip: Tip\nThe provided points for the potential should be in Cartesian coordinates. The returned fields are also in Cartesian from.","category":"page"},{"location":"operators/maxwelldoublelayer/","page":"Time Harmonic","title":"Time Harmonic","text":"warning: Warning\nSingularities are not addressed: the case when the evaluation point is close to the surface is not treated properly, so far.","category":"page"},{"location":"operators/maxwellsinglelayer_td/#MWsinglelayerTDDef","page":"Time Domain","title":"Maxwell Single Layer Operator","text":"","category":"section"},{"location":"operators/maxwellsinglelayer_td/","page":"Time Domain","title":"Time Domain","text":"Text","category":"page"},{"location":"operators/maxwellsinglelayer_td/","page":"Time Domain","title":"Time Domain","text":"","category":"page"},{"location":"operators/maxwellsinglelayer_td/#Definition","page":"Time Domain","title":"Definition","text":"","category":"section"},{"location":"operators/maxwellsinglelayer_td/","page":"Time Domain","title":"Time Domain","text":"Text","category":"page"},{"location":"operators/maxwellsinglelayer_td/","page":"Time Domain","title":"Time Domain","text":"","category":"page"},{"location":"operators/maxwellsinglelayer_td/#As-...","page":"Time Domain","title":"As ...","text":"","category":"section"},{"location":"operators/overview/#operator","page":"Overview","title":"Operator Overview","text":"","category":"section"},{"location":"operators/overview/","page":"Overview","title":"Overview","text":"using TypeTree\nusing BEAST\n\nprint(join(tt(BEAST.Operator), \"\"))\nprint(\"\\n\\n\\n\")#hide\nprint(join(tt(BEAST.SpaceTimeOperator), \"\"))","category":"page"},{"location":"internals/overview/#InternalsRef","page":"Overview","title":"Internals","text":"","category":"section"},{"location":"internals/overview/","page":"Overview","title":"Overview","text":"In general, the framework is designed such that it allows to easily add support for more kernels, finite element spaces, and excitations.\nKey are assembly routines that take in symbolic representations of the defining bilinear form. Support for block systems and finite element spaces defined in terms of direct products or tensor products of atomic spaces.","category":"page"},{"location":"internals/overview/#Basis","page":"Overview","title":"Basis","text":"","category":"section"},{"location":"internals/overview/","page":"Overview","title":"Overview","text":"Sets of both trial and testing functions are implemented by models following the basis concept. The term basis is somewhat misleading as it is nowhere required nor enforced that these functions are linearly independent. Models implementing the Basis concept need to comply to the following semantics.","category":"page"},{"location":"internals/overview/","page":"Overview","title":"Overview","text":"numfunctions(basis): number of functions in the Basis.\ncoordtype(basis): type of (the components of) the values taken on by the functions in the Basis.\nscalartype(d): the scalar field underlying the vector space the basis functions take value in.\nrefspace(basis): returns the ReferenceSpace of local shape functions on which the Basis is built.\nassemblydata(basis): assemblydata returns an iterable collection elements of geometric elements and a look table ad for use in assembly of interaction matrices. In particular, for an index element_idx into elements and an index local_shape_idx in basis of local shape functions refspace(basis), ad[element_idx, local_shape_idx] returns the iterable collection of (global_idx, weight) tuples such that the local shape function at local_shape_idx defined on the element at element_idx contributes to the basis function at global_idx with a weight of weight.\ngeometry(basis): returns an iterable collection of Elements. The order in which these Elements are encountered corresponds to the indices used in the assembly data structure.","category":"page"},{"location":"internals/overview/#Reference-Space","page":"Overview","title":"Reference Space","text":"","category":"section"},{"location":"internals/overview/","page":"Overview","title":"Overview","text":"The reference space concept defines an API for working with spaces of local shape functions. The main role of objects implementing this concept is to allow specialization of the functions that depend on the precise reference space used.","category":"page"},{"location":"internals/overview/","page":"Overview","title":"Overview","text":"The functions that depend on the type and value of arguments modeling reference space are:","category":"page"},{"location":"internals/overview/","page":"Overview","title":"Overview","text":"numfunctions(refspace, domain): returns the number of shape functions on each element.","category":"page"},{"location":"internals/overview/#Kernel","page":"Overview","title":"Kernel","text":"","category":"section"},{"location":"internals/overview/","page":"Overview","title":"Overview","text":"A kernel is a fairly simple concept that mainly exists as part of the definition of a Discrete Operator. A kernel should obey the following semantics:","category":"page"},{"location":"internals/overview/","page":"Overview","title":"Overview","text":"In many function definitions the kernel object is referenced by operator or something similar. This is a misleading name as an operator definition should always be accompanied by the domain and range space.","category":"page"},{"location":"internals/overview/#Discrete-Operator","page":"Overview","title":"Discrete Operator","text":"","category":"section"},{"location":"internals/overview/","page":"Overview","title":"Overview","text":"Informally speaking, a Discrete Operator is a concept that allows for the computation of an interaction matrix. It is a kernel together with a test and trial basis. A Discrete Operator can be passed to assemble and friends to compute its matrix representation.","category":"page"},{"location":"internals/overview/","page":"Overview","title":"Overview","text":"A discrete operator is a triple (kernel, test_basis, trial_basis), where kernel is a Kernel, and test_basis and trial_basis are Bases. In addition, the following expressions should be implemented and behave according to the correct semantics:","category":"page"},{"location":"internals/overview/","page":"Overview","title":"Overview","text":"quaddata(operator,test_refspace,trial_refspace,test_elements,trial_elements): create the data required for the computation of element-element interactions during assembly of discrete operator matrices.\nquadrule(operator,test_refspace,trial_refspace,p,test_element,q_trial_element,qd): returns an integration strategy object that will be passed to momintegrals! to select an integration strategy. This rule can depend on the test/trial reference spaces and interacting elements. The indices p and q refer to the position of the interacting elements in the enumeration defined by geometry(basis) and allow for fast retrieval of any element specific data stored in the quadrature data object qd.\nmomintegrals!(operator,test_refspace,trial_refspace,test_element,trial_element,zlocal,qr): this function computes the local interaction matrix between the set of local test and trial shape functions and a specific pair of elements. The target matrix zlocal is provided as an argument to minimise memory allocations over subsequent calls. qr is an object returned by quadrule and contains all static and dynamic data defining the integration strategy used.","category":"page"},{"location":"internals/overview/","page":"Overview","title":"Overview","text":"In the context of fast methods such as the Fast Multipole Method other algorithms on Discrete Operators will typically be defined to compute matrix vector products. These algorithms do not explicitly compute and store the interaction matrix (this would lead to unacceptable computational and memory complexity).","category":"page"},{"location":"internals/overview/#BEAST.elements-internals-overview","page":"Overview","title":"BEAST.elements","text":"elements(geo)\n\nCreate an iterable collection of the elements stored in geo. The order in which this collection produces the elements determines the index used for lookup in the data structures returned by assemblydata and quaddata.\n\n\n\n\n\n","category":"function"},{"location":"internals/overview/#BEAST.numfunctions-internals-overview","page":"Overview","title":"BEAST.numfunctions","text":"numfunctions(basis)\n\nNumber of functions in the basis.\n\n\n\n\n\n","category":"function"},{"location":"internals/overview/#BEAST.scalartype-internals-overview","page":"Overview","title":"BEAST.scalartype","text":"scalartype(x)\n\nThe scalar field over which the values of a global or local basis function, or an operator are defined. This should always be a scalar type, even if the basis or operator takes on values in a vector or tensor space. This data type is used to determine the eltype of assembled discrete operators.\n\n\n\n\n\n","category":"function"},{"location":"internals/overview/#BEAST.assemblydata-internals-overview","page":"Overview","title":"BEAST.assemblydata","text":"charts, admap, act_to_global = assemblydata(basis; onlyactives=true)\n\nGiven a basis this function returns a data structure containing the information required for matrix assemble, that is, the vector charts containing Simplex elements, a variable admap of type AssemblyData, and a mapping from indices of actively used simplices to global simplices.\n\nWhen onlyactives is true, another layer of indices is introduced to filter out all cells of the mesh that are not in the union of the support of the basis functions (i.e., when the basis functions are defined only on a part of the mesh).\n\nadmap is, in essence, a three-dimensional array of named tuples, which, by wrapping it in the struct AssemblyData, allows the definition of iterators. The tuple consists of the two entries\n\nadmap[i,r,c].globalindex\nadmap[i,r,c].coefficient\n\nHere, c and r are indices in the iterable set of (active) simplices and the set of shape functions on each cell/simplex: r ranges from 1 to the number of shape functions on a cell/simplex, c ranges from 1 to the number of active simplices, and i ranges from 1 to the number of maximal number of basis functions, where any of the shape functions contributes to. \n\nFor example, for continuous piecewise linear lagrange functions (c0d1), each of the three shape functions on a triangle are associated with exactly one Lagrange function, and therefore i is limited to 1.\n\nNote: When onlyactives=false, the indices c correspond to the position of the corresponding cell/simplex whilst iterating over geometry(basis). When onlyactives=true, then act_to_global(c) correspond to the position of the corresponding cell/simplex whilst iterating over geometry(basis).\n\nFor a triplet (i,r,c), globalindex is the index in the basis of the ith basis function that has a contribution from shape function r on (active) cell/simplex c. coefficient is the coefficient of that contribution in the linear combination defining that basis function in terms of shape function.\n\n\n\n\n\n","category":"function"},{"location":"internals/overview/#BEAST.geometry-internals-overview","page":"Overview","title":"BEAST.geometry","text":"geometry(basis)\n\nReturns an iterable collection of geometric elements on which the functions in basis are defined. The order the elements are encountered needs correspond to the element indices used in the data structure returned by assemblydata.\n\n\n\n\n\n","category":"function"},{"location":"internals/overview/#BEAST.refspace-internals-overview","page":"Overview","title":"BEAST.refspace","text":"refspace(basis)\n\nReturns the ReferenceSpace of local shape functions on which the basis is built.\n\n\n\n\n\n","category":"function"},{"location":"internals/overview/#BEAST.quaddata-internals-overview","page":"Overview","title":"BEAST.quaddata","text":"quaddata(operator, test_refspace, trial_refspace, test_elements, trial_elements)\n\nReturns an object cashing data required for the computation of boundary element interactions. It is up to the client programmer to decide what (if any) data is cached. For double numberical quadrature, storing the integration points for example can significantly speed up matrix assembly.\n\noperator is an integration kernel.\ntest_refspace and trial_refspace are reference space objects. quadata\n\nis typically overloaded on the type of these local spaces of shape functions. (See the implementation in maxwell.jl for an example).\n\ntest_elements and trial_elements are iterable collections of the geometric\n\nelements on which the finite element space are defined. These are provided to allow computation of the actual integrations points - as opposed to only their coordinates.\n\n\n\n\n\n","category":"function"},{"location":"internals/overview/#BEAST.quadrule-internals-overview","page":"Overview","title":"BEAST.quadrule","text":"quadrule(operator, test_refspace, trial_refspace, test_index, test_chart, trial_index, trial_chart, quad_data)\n\nBased on the operator kernel and the test and trial elements, this function builds an object whose type and data fields specify the quadrature rule that needs to be used to accurately compute the interaction integrals. The quad_data object created by quaddata is passed to allow reuse of any precomputed data such as quadrature points and weights, geometric quantities, etc.\n\nThe type of the returned quadrature rule will help in deciding which method of momintegrals to dispatch to.\n\n\n\n\n\n","category":"function"},{"location":"internals/overview/#BEAST.momintegrals!-internals-overview","page":"Overview","title":"BEAST.momintegrals!","text":"momintegrals!(biop, tshs, bshs, tcell, bcell, interactions, strat)\n\nFunction for the computation of moment integrals using simple double quadrature.\n\n\n\n\n\n","category":"function"},{"location":"#BEAST.jl","page":"Introduction","title":"BEAST.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This Julia package, the boundary element analysis and simulation toolkit (BEAST), provides routines to convert integral and differential equations to linear systems of equations via the boundary element method (BEM) and the finite element method (FEM).  To this end, the (Petrov-) Galerkin method is employed.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently, the focus is on equations encountered in classical electromagnetism, where frequency and time domain equations are covered. Several operators, basis functions, and geometry representations are implemented.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nSI units and for time-harmonic simulations a time convention of mathrme^mathrmjomega t are used everywhere.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Tip\nTo use the code have a look at the general usage.However, the code is designed such that users can easily hook into the code at any level and implement new features. To do so, have a look at the internals documentation and the contribution guidelines. Design goals are extendability and a performant execution. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Installing BEAST is done by entering the package manager (enter ] at the julia REPL) and issuing:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add BEAST ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following operators, basis functions, and geometry representations are implemented. To see details and all variations, have a look at the corresponding sections of this documentation.","category":"page"},{"location":"#Operators","page":"Introduction","title":"Operators","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Boundary Integral operators\nMaxwell (3D)\nSingle Layer (time-harmonic & time-domain)\nDouble Layer (time-harmonic & time-domain)\nHelmholtz (2D & 3D)\nSingle Layer\nDouble Layer\nVolume Integral operators\nMaxwell\nSingle Layer (time-harmonic)\nDouble Layer (time-harmonic)\nLocal Operators\nIdentity (+ variations thereof)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<br/>","category":"page"},{"location":"#Basis-functions","page":"Introduction","title":"Basis functions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Spatial\nLow Order \nRaviart-Thomas / Rao-Wilton-Glisson\nBuffa-Christiansen\nBrezzi-Douglas-Marini\nHigh Order\nGraglia-Wilton-Peterson (GWP)\nB-Spline based","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Temporal\nLagrange?\n...","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<br/>","category":"page"},{"location":"#Geometry-Representations","page":"Introduction","title":"Geometry Representations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Low Order (\"flat\")\nTriangular\nQuadrilaterals\nTetrahedra","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"High Order (curvilinear)\nNURBS-surfaces","category":"page"}]
}
