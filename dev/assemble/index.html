<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Matrix Assemble Routine · BEAST Documentation</title><meta name="title" content="The Matrix Assemble Routine · BEAST Documentation"/><meta property="og:title" content="The Matrix Assemble Routine · BEAST Documentation"/><meta property="twitter:title" content="The Matrix Assemble Routine · BEAST Documentation"/><meta name="description" content="Documentation for BEAST Documentation."/><meta property="og:description" content="Documentation for BEAST Documentation."/><meta property="twitter:description" content="Documentation for BEAST Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BEAST Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">BEAST.jl documentation</a></li><li class="is-active"><a class="tocitem" href>The Matrix Assemble Routine</a><ul class="internal"><li><a class="tocitem" href="#Case-Study:-Implementation-of-the-Nitsche-Operator-Assembly"><span>Case Study: Implementation of the Nitsche Operator Assembly</span></a></li></ul></li><li><a class="tocitem" href="../assets/postproc/">Post-processing and Visualisation</a></li><li><a class="tocitem" href="../quadstrat/">Quadrature strategies</a></li><li><a class="tocitem" href="../tdefie/">Solving the Time Domain EFIE using Marching-on-in-Time</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The Matrix Assemble Routine</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Matrix Assemble Routine</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/krcools/BEAST.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/krcools/BEAST.jl/blob/master/docs/src/assemble.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Matrix-Assemble-Routine"><a class="docs-heading-anchor" href="#The-Matrix-Assemble-Routine">The Matrix Assemble Routine</a><a id="The-Matrix-Assemble-Routine-1"></a><a class="docs-heading-anchor-permalink" href="#The-Matrix-Assemble-Routine" title="Permalink"></a></h1><p>A lot of the design of this package derives from the need to express boundary element and finite element matrix assembly in a concise but general manner that is compatible with a wide range of linear and bilinear forms as encountered in the solution of variational problems.</p><p>In this section the matrix assembly routine at the center of this package will be discussed. As a case study we will go over the steps required to extend support for new kernels and new finite element spaces.</p><p>The matrix assemble routine is surprisingly short:</p><pre><code class="language-julia hljs">function assemblechunk!(biop::IntegralOperator, tfs::Space, bfs::Space, store)

    test_elements, tad = assemblydata(tfs)
    bsis_elements, bad = assemblydata(bfs)

    tshapes = refspace(tfs); num_tshapes = numfunctions(tshapes)
    bshapes = refspace(bfs); num_bshapes = numfunctions(bshapes)

    T = promote_type(scalartype(biop), scalartype(tfs), scalartype(bfs))
    zlocal = zeros(T, num_tshapes, num_bshapes)

    qd = quaddata(biop, tshapes, bshapes, test_elements, bsis_elements)
    for (p,tcell) in enumerate(test_elements), (q,bcell) in enumerate(bsis_elements)

        fill!(zlocal, 0)
        strat = quadrule(biop, tshapes, bshapes, p, tcell, q, bcell, qd)
        momintegrals!(biop, tshapes, bshapes, tcell, bcell, zlocal, strat)

        for j in 1 : num_bshapes, i in 1 : num_tshapes
            z = zlocal[i,j]
            for (m,a) in tad[p,i], (n,b) in bad[q,j]
                store(a*z*b, m, n)
end end end end</code></pre><p>Support for direct product spaces, linear combinations of kernels, non-standard storage of matrix elements, and parallel execution is provided by layers on top of this assembly routine. In this section we will focus on discussing the design and implementation of this inner building block that lies at the basis of more general functionality.</p><p>Finite element spaces are usually stored as a collection of functions that in turn each comprise contributions from a limited number of geometric elements that make up the support of the function. In FEM and BEM matrix assembly, however, we need the <em>tranposed</em> information: given a geometric cell, and a local shape function, we need the ability to efficiently retrieve the list of basis functions whose definition contains the given local shape function on the given cell and the weight (aka coefficient) by which it contributes. The data structure that contains this information is referred to as the assembly data <code>ad</code>. In particular, <code>ad[e,s]</code>, where <code>e</code> is the index of a geometric cell and <code>s</code> is the index of a local shape function, returns an iterable collection of pairs <code>(m,w)</code> where <code>m</code> is an index into the iterable collection of basis functions making up the finite element space and <code>w</code> is a weight, such that shape function <code>s</code> on geometric element <code>e</code> contributes with weight <code>w</code> to basis function <code>n</code>.</p><pre><code class="language-julia hljs">test_elements, tad = assemblydata(tfs)
bsis_elements, bad = assemblydata(bfs)</code></pre><p>One final note on the <code>assemblydata</code> function: as you can see from the above snippet, the function returns, in addition to the actual assembly data, an iterable collection of geometric elements. This collection is a subset of the collection of elements making up the geometry on which the finite element space is defined. The elements returned are those that actually appear in the domain of one or more of the functions that span the finite element space. The double for loop that iterates over pairs of trial and testing functions will only visit those used elements. Elements that are part of the geometry but do not appear as part of the support of a function are skipped. This behaviour is required to guarantee scalability when using multiple threads in assembling the matrix: each thread is assigned a subset of the basis functions; visiting unused elements in all threads is harmful for the overall efficiency.</p><p>With this assembly data in hand, matrix assembly can be done by iterating over geometric cells, rather than over basis functions. Doing this avoids visiting a given geometric cell more than once. When computing matrices resulting from discretisation with e.g. Raviart-Thomas elements, this can speed up assembly time with a factor 9.</p><p>The problem of matrix assembly is now reduced to the computation of interactions between local shape functions defined on all possible pairs of geometric cells. The space of local shape functions can be retrieved by calling</p><pre><code class="language-julia hljs">tshapes = refspace(tfs); num_tshapes = numfunctions(tshapes)
bshapes = refspace(bfs); num_bshapes = numfunctions(bshapes)</code></pre><p>Here, <code>num_tshapes</code> and <code>num_bshapes</code> are the number of local shape functions. For example, when using Raviart-Thomas elements, the number of local shape functions equals three (one for every edge of the reference triangle).</p><p>Based on this dimension, and based on the types used to represent numbers in the fields over which the spaces and the kernel are defined, the storage for local shape function interaction is pre-allocated:</p><pre><code class="language-julia hljs">T = promote_type(scalartype(biop), scalartype(tfs), scalartype(bfs))
zlocal = zeros(T, num_tshapes, num_bshapes)</code></pre><p>Note that the computation of the storage type ensures that high precision or complex data types are only used when required. At all times the minimal storage type is selected. Not only does this keep memory use down, it also results in faster linear algebra computations such as matrix-vector multiplication.</p><p>Before entering the double for loop that is responsible for the enumeration of all pairs of geometric cells (a trial cell pairs with a test cell), the implementer is given the opportunity to precompute data for use in the integration kernels. For example when using numerical quadrature rules to compute the double integral in the expression of the matrix entries, it is likely that a set of quadrature points for any given trial cells will be reused in interactions with a large number of test cells. To avoid computing these points and weights over and over, the client developer is given the opportunity to compute and store them by providing an appropriate method for <code>quaddata</code> . If memory use is more important the runtime, the client programmer is perfectly allowed to compute points and weights on the fly without storing them.</p><pre><code class="language-julia hljs">fill!(zlocal, 0)
strat = quadrule(biop, tshapes, bshapes, p, tcell, q, bcell, qd)
momintegrals!(biop, tshapes, bshapes, tcell, bcell, zlocal, strat)</code></pre><p>For a given pair <code>(tcell,bcell)</code> of test cell and trial cell (with respective indices <code>p</code> and <code>q</code> in collections <code>test_elements</code> and <code>bsis_elements</code>), all possible interactions between local shape functions are computed. After resetting the buffer used to store these interactions, the quadrature strategy is determined. The quadrature strategy in general could depend on:</p><ul><li>the kernel <code>biop</code> defining the integral operator,</li><li>the local test and trial shape functions <code>tshapes</code> and <code>bshapes</code> (functions of high polynomial degree and functions that are highly oscillatory typically require bespoke integration methods),</li><li>and the geometric test and trial cells <code>tcell</code> and <code>bcell</code> (cells that touch or are near to each other lead to quickly varying or even singular integrands requiring dedicated integration rules).</li></ul><p>The method returns an object <code>strat</code> that: (i) describes (by its type and its data fields) the integration strategy that is appropriate to compute the current set of local interactions, (ii) contains all data precomputed and stored in <code>qd</code> that is relevant to this particular integration (for example a set of quadrature points and weights). This explains why the indices <code>p</code> and <code>q</code> where passed too <code>quadrule</code>: they allow for the quick retrieval of relevant pre-stored data from <code>qd</code>.</p><p>The routing that is responsible for the actual computation of the interactions between the local shape functions takes the quadrule object <code>strat</code> as one of its arguments. The idea is that <code>momintegrals!</code> has many methods, not only for different types of kernel and shape functions, but also for different types of <code>strat</code>. For example, there are implementations of <code>momintegrals!</code> for the computation of the Maxwellian single layer operator w.r.t. spaces of Raviart-Thomas elements that employ double numerical quadrature, singularity extraction, and even more advanced integration routines.</p><p><em>Note</em>: the type of <code>strat</code> depends on the orientation of the two interacting geometric cells. This information is only available at runtime. In other words, there will be a slight type instability at this point in the code. This is by design however, and not different from the use of virtual functions in an c++ implementation. Numerical experiments show that this form of runtime polymorphism results in negligible runtime overhead.</p><p>When all possible interactions between local shape functions have been computed, they need to be stored in the global system matrix. This is done in the matrix assembly loop:</p><pre><code class="language-julia hljs">for j in 1 : num_bshapes
    for i in 1 : num_tshapes
        z = zlocal[i,j]
        for (m,a) in tad[p,i]
            for (n,b) in bad[q,j]
                store(a*z*b, m, n)
            end
        end
    end
end</code></pre><p>For both the test and trial local shape functions, the global indices at which they appear in the finite element space (and the corresponding weights) are retrieved from the assembly data objects. The contributing value <code>v = a*z*b</code> is constructed and its storage is delegated to the <code>store</code> method, which we received as one of the arguments passed to <code>assemble_chunk!</code>. In the simplest case, <code>assemble_chunk!</code> can be used like this:</p><pre><code class="language-julia hljs">Z = zeros(ComplexF64, numfunctions(tfs), numfunctions(bfs))
store(v, m, n) = (Z[m,n] += v)
assemble_chunk!(kernel, tfs, bfs, store)</code></pre><p>In other words <code>store</code> will simply add the computed value to the specified entry in the global system matrix. Allowing the caller to specify <code>store</code> as an argument allows for more flexibility than hardcoding this behaviour in the assembly routine. Indeed, when computing blocks of a larger system, or when e.g. the transposed or a multiple of a given operator is desired, a fairly simple redefinition of <code>store</code> can provide this functionality. This is also the reason why <code>assemble_chunk!</code> ends in an exclamation mark: even though strictly speaking none of the arguments are modified, the function clearly has an effect on variables defined outside of its scope!</p><h2 id="Case-Study:-Implementation-of-the-Nitsche-Operator-Assembly"><a class="docs-heading-anchor" href="#Case-Study:-Implementation-of-the-Nitsche-Operator-Assembly">Case Study: Implementation of the Nitsche Operator Assembly</a><a id="Case-Study:-Implementation-of-the-Nitsche-Operator-Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Case-Study:-Implementation-of-the-Nitsche-Operator-Assembly" title="Permalink"></a></h2><p>In the Nitsche method for the Maxwell system, penalty terms are added to the classic discretisation of the EFIE. When discretized using a non-conforming finite elements space (typically because the underlying geometric mesh is not conforming), the penalty term will force the solution to be divergence conforming in some weak sense. The penalty term derives from the following bilinear form:</p><p class="math-container">\[p(v,u) = \int_{\gamma} v(x) \int_{Γ} \frac{e^{-ik|x-y|}}{4π|x-y|} u(y) dy dx\]</p><p>Note that <span>$u(x)$</span> is supported by a 2D surface <span>$Γ$</span> whereas <span>$v(y)$</span> is supported by a 1D curve <span>$γ$</span>. The complete implementation of this operator could look like</p><pre><code class="language-julia hljs">mutable struct SingleLayerTrace{T} &lt;: MaxwellOperator3D
    gamma::T
end

function quaddata(operator::SingleLayerTrace,
    localtestbasis::LagrangeRefSpace,  localtrialbasis::LagrangeRefSpace,
    testelements,  trialelements)

  tqd = quadpoints(localtestbasis,  testelements,  (10,))
  bqd = quadpoints(localtrialbasis, trialelements, (8,))

  return (tpoints=tqd, bpoints=bqd)
end

function quadrule(op::SingleLayerTrace, g::LagrangeRefSpace, f::LagrangeRefSpace, i, τ, j, σ, qd)
    DoubleQuadRule(
        qd.tpoints[1,i],
        qd.bpoints[1,j]
    )
end

integrand(op::SingleLayerTrace, kernel, g, τ, f, σ) = f[1]*g[1]*kernel.green</code></pre><p>Every kernel corresponds with a type. Kernels can potentially depend on a set of parameters; these appear as fields in the type. Here our Nitsche kernel depends on the wavenumber. In quaddata we precompute quadrature points for all geometric cells in the supports of test and trial elements. This is fairly sloppy: only one rule for test and trial integration is considered. A high accuracy implementation would typically compute points for both low quality and high quality quadrature rules.</p><p>Also <code>quadrule</code> is sloppy: we always select a <code>DoubleQuadRule</code> to perform the computation of interactions between local shape functions. No singularity extraction or other advanced technique is considered for nearby interactions. Clearly amateurs at work here!</p><p><code>BEAST</code> provides a default implementation of an integration routine using double numerical quadrature. All that is required to tap into that implementation is a method overloading <code>integrand</code>. From the above formula it is clear what this method should look like.</p><p>That&#39;s it!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« BEAST.jl documentation</a><a class="docs-footer-nextpage" href="../assets/postproc/">Post-processing and Visualisation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 2 May 2024 10:13">Thursday 2 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
