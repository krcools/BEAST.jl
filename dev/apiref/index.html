<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · BEAST.jl</title><meta name="title" content="API Reference · BEAST.jl"/><meta property="og:title" content="API Reference · BEAST.jl"/><meta property="twitter:title" content="API Reference · BEAST.jl"/><meta name="description" content="Documentation for BEAST.jl."/><meta property="og:description" content="Documentation for BEAST.jl."/><meta property="twitter:description" content="Documentation for BEAST.jl."/><meta property="og:url" content="https://krcools.github.io/BEAST.jl/apiref/"/><meta property="twitter:url" content="https://krcools.github.io/BEAST.jl/apiref/"/><link rel="canonical" href="https://krcools.github.io/BEAST.jl/apiref/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="BEAST.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="BEAST.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">BEAST.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/usage/">General Usage</a></li><li><a class="tocitem" href="../manual/customexc/">Custom excitations</a></li><li><a class="tocitem" href="../manual/quadstrat/">Setting the Quadrature Strategy</a></li><li><a class="tocitem" href="../manual/quadrule/">Custom Quadrature Rules</a></li><li><a class="tocitem" href="../manual/customop/">Custom Operators</a></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Application Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-6-1" type="checkbox"/><label class="tocitem" for="menuitem-2-6-1"><span class="docs-label">Time-Harmonic</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/examplesTH/efie/">EFIE</a></li><li><a class="tocitem" href="../manual/examplesTH/mfie/">MFIE</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6-2" type="checkbox"/><label class="tocitem" for="menuitem-2-6-2"><span class="docs-label">Time-Domain</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/examplesTD/tdefie/">EFIE</a></li></ul></li></ul></li><li><a class="tocitem" href="../manual/bilinear/">System of Equations and Bilinear Forms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/efie/">EFIE</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Operators &amp; Excitations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../operators/overview/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Local Operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../operators/identity/">Identiy</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Boundary Integral Operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../operators/helmholtz/">Helmholtz</a></li><li><input class="collapse-toggle" id="menuitem-4-3-2" type="checkbox"/><label class="tocitem" for="menuitem-4-3-2"><span class="docs-label">Maxwell Single Layer</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../operators/maxwellsinglelayer/">Time Harmonic</a></li><li><a class="tocitem" href="../operators/maxwellsinglelayer_td/">Time Domain</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3-3"><span class="docs-label">Maxwell Double Layer</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../operators/maxwelldoublelayer/">Time Harmonic</a></li><li><a class="tocitem" href="../operators/maxwelldoublelayer_td/">Time Domain</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Volume Integral Operators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../operators/maxwellsinglelayerVIE/">Maxwell Single Layer</a></li><li><span class="tocitem">Maxwell Double Layer</span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Excitations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../excitations/planewave/">Plane Wave</a></li><li><a class="tocitem" href="../excitations/dipole/">Dipole</a></li><li><a class="tocitem" href="../excitations/monopole/">Monopole</a></li><li><a class="tocitem" href="../excitations/linearpotential/">Linear Potential</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Composed Operator</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../composedoperator/composedoperator/">Composed Operator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Quasi Helmholtz Projectors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../projectors/pmchwt_lf/">Low Frequency Stable PMCHWT</a></li><li><a class="tocitem" href="../projectors/pmchwt_theta/">Dense Grid Stable PMCHWT</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Basis Functions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../bases/overview/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Spatial</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../bases/raviartthomas/">Raviart Thomas</a></li><li><a class="tocitem" href="../bases/buffachristiansen/">Buffa Christiansen</a></li><li><a class="tocitem" href="../bases/brezzidouglasmarini/">Brezzi-Douglas-Marini</a></li><li><a class="tocitem" href="../bases/gragliawiltonpeterson/">Graglia-Wilton-Peterson</a></li></ul></li><li><span class="tocitem">Temporal</span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Geometry Representations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../geometry/flat/">Flat</a></li><li><span class="tocitem">Curvilinear</span></li></ul></li><li><span class="tocitem">____________________________________</span></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../internals/overview/">Overview</a></li><li><a class="tocitem" href="../internals/assemble/">The Matrix Assemble Routine</a></li><li><a class="tocitem" href="../internals/quadstrat/">Quadrature</a></li><li><span class="tocitem">Parametric Domain</span></li><li><span class="tocitem">Multithreading</span></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">References</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../references/">References</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/krcools/BEAST.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/krcools/BEAST.jl/blob/master/docs/src/apiref.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="BEAST.pvrtrace"><a class="docstring-binding" href="#BEAST.pvrtrace"><code>BEAST.pvrtrace</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">pvrtrace(Potential,interior::Bool)</code></pre><p>Compute the principal value of the rotated trace, n× Potential.</p><p>This function assumes the normalvector on the mesh to point outwards. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/composedoperators/trace.jl#L227-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.volumetrace"><a class="docstring-binding" href="#BEAST.volumetrace"><code>BEAST.volumetrace</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">volumetrace(Potential)</code></pre><p>Mapping the potential to a volume operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/composedoperators/trace.jl#L236-L240">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.DoubleLayerRotatedMW3D"><a class="docstring-binding" href="#BEAST.DoubleLayerRotatedMW3D"><code>BEAST.DoubleLayerRotatedMW3D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DoubleLayerRotatedMW3D{T,K} &lt;: MaxwellOperator3D{T,K}

Bilinear form given by:

```math
    α ∬_{Γ^2} k(x) ⋅ [n̂(x) × (∇G_γ(x-y) × j(y))]
```

with ``G_γ = e^{-γ|x-y|} / 4π|x-y|``</code></pre><p><strong>Fields</strong></p><ul><li><code>alpha::T</code>: Factor in front of bilinear form.</li><li><code>gamma::K</code>: imaginary unit times the wavenumber.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/nxdbllayer.jl#L1-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.GlobalDisplacementMesh"><a class="docstring-binding" href="#BEAST.GlobalDisplacementMesh"><code>BEAST.GlobalDisplacementMesh</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>GlobalDisplacementMesh(mesh,epsilon)     every chart is displaced with epsilon allong the normal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/composedoperators/displacementmesh.jl#L4-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.HH2DDirectedMonopole"><a class="docstring-binding" href="#BEAST.HH2DDirectedMonopole"><code>BEAST.HH2DDirectedMonopole</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HH2DDirectedMonopole</code></pre><p>Potential of a monopole-type point source (e.g., of an electric charge)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/helmholtz2d/hh2dexc.jl#L150-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.HH2DMonopole"><a class="docstring-binding" href="#BEAST.HH2DMonopole"><code>BEAST.HH2DMonopole</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HH2DMonopole</code></pre><p>Potential of a monopole-type point source (e.g., of an electric charge)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/helmholtz2d/hh2dexc.jl#L61-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.HH3DHyperSingularFDBIO"><a class="docstring-binding" href="#BEAST.HH3DHyperSingularFDBIO"><code>BEAST.HH3DHyperSingularFDBIO</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">∫_Γ dx ∫_Γ dy \left(α G g(x) n_x ⋅ n_y f(y) + β G \mbox{curl} g(x) ⋅ \mbox{curl} f(y) \right)</code></pre><p>with <span>$G(x,y) = \frac{e^{-γ |x-y|}}{4 π |x-y|}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/helmholtz3d/hh3dops.jl#L3-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.HH3DLinearPotential"><a class="docstring-binding" href="#BEAST.HH3DLinearPotential"><code>BEAST.HH3DLinearPotential</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HH3DLinearPotential</code></pre><p>A potential that linearly increases in <code>direction</code> with scaling coefficient <code>amplitude</code>. Its negative gradient will be a uniform vector field pointing in the opposite direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/helmholtz3d/hh3dexc.jl#L20-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.HH3DMonopole"><a class="docstring-binding" href="#BEAST.HH3DMonopole"><code>BEAST.HH3DMonopole</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HH3DMonopole</code></pre><p>Potential of a monopole-type point source (e.g., of an electric charge)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/helmholtz3d/hh3dexc.jl#L68-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.HH3DSingleLayerFDBIO"><a class="docstring-binding" href="#BEAST.HH3DSingleLayerFDBIO"><code>BEAST.HH3DSingleLayerFDBIO</code></a> — <span class="docstring-category">Type</span></summary><section><div><p class="math-container">\[a(u,v) = α ∬_{Γ×Γ} u(x) G_{γ}(|x-y|) v(y)\]</p><p>with <span>$G_{γ}(r) = \frac{e^{-γr}}{4πr}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/helmholtz3d/hh3dops.jl#L41-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.Identity"><a class="docstring-binding" href="#BEAST.Identity"><code>BEAST.Identity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Identity &lt;: LocalOperator</code></pre><p>The identity operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/identityop.jl#L2-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.LinearCombinationOfOperators"><a class="docstring-binding" href="#BEAST.LinearCombinationOfOperators"><code>BEAST.LinearCombinationOfOperators</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearCombinationOfOperators{T} &lt;: AbstractOperator</code></pre><p>A linear combination of operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/operator.jl#L22-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.MWDoubleLayerFarField3D-Tuple{}"><a class="docstring-binding" href="#BEAST.MWDoubleLayerFarField3D-Tuple{}"><code>BEAST.MWDoubleLayerFarField3D</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>MWDoubleLayerFarField3D(;gamma, amplitude)</p><p>Maxwell double layer far-field operator for 3D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/farfield.jl#L37-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.MWDoubleLayerField3D-Tuple{}"><a class="docstring-binding" href="#BEAST.MWDoubleLayerField3D-Tuple{}"><code>BEAST.MWDoubleLayerField3D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MWDoubleLayerField3D(; gamma, wavenumber)</code></pre><p>Create the double layer near field operator, for use with <code>potential</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/nearfield.jl#L36-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.MWDoubleLayerRotatedFarField3D-Tuple{}"><a class="docstring-binding" href="#BEAST.MWDoubleLayerRotatedFarField3D-Tuple{}"><code>BEAST.MWDoubleLayerRotatedFarField3D</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>MWDoubleLayerRotatedFarField3D</p><p>Rotated Maxwell double layer far-field operator for 3D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/farfield.jl#L78-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.MWFarField3D-Tuple{}"><a class="docstring-binding" href="#BEAST.MWFarField3D-Tuple{}"><code>BEAST.MWFarField3D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MWFarField3D(;gamma, amplitude)</code></pre><p>Maxwell single layer far-field operator for 3D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/farfield.jl#L17-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.MWFarField3DTD"><a class="docstring-binding" href="#BEAST.MWFarField3DTD"><code>BEAST.MWFarField3DTD</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Operatorss to compute the far field of a current distribution in the time domain. In particular, given the current distribution <span>$j$</span> this operator allows for the computation of</p><p class="math-container">\[\text{ffd} = n × ∫_Γ j(r&#39;, t - x⋅y/c) dy\]</p><p>where <span>$x$</span> is the unit vector in the direction of observation. Note that the assembly routing expects the observation directions to be normalised by the caller.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/timedomain/tdfarfield.jl#L3-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.MWSingleLayerField3D-Tuple{}"><a class="docstring-binding" href="#BEAST.MWSingleLayerField3D-Tuple{}"><code>BEAST.MWSingleLayerField3D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MWSingleLayerField3D(;gamma, wavenumber, alpha, beta)</code></pre><p>Create the single layer near field operator, for use with <code>potential</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/nearfield.jl#L13-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.NCross"><a class="docstring-binding" href="#BEAST.NCross"><code>BEAST.NCross</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NCross &lt;: LocalOperator</code></pre><p>The identity operator where the trial function is rotated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/identityop.jl#L14-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.NDRefSpace"><a class="docstring-binding" href="#BEAST.NDRefSpace"><code>BEAST.NDRefSpace</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Local shape function <code>r</code> is the one whose field lines straddle local edge <code>r</code>, which is the edge adjacent to vertex <code>r</code>.</p><p>This is not the edge starting at vertex <code>r</code>. The downside of this local numbering scheme is that it cannot be extended to cells that are not simplices because there is no well defined concept of adjacent-ness.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/local/ndlocal.jl#L1-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.Operator"><a class="docstring-binding" href="#BEAST.Operator"><code>BEAST.Operator</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><em>Atomic operator</em>: one that assemblechunk can deal with</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/operator.jl#L9-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.RungeKuttaConvolutionQuadrature"><a class="docstring-binding" href="#BEAST.RungeKuttaConvolutionQuadrature"><code>BEAST.RungeKuttaConvolutionQuadrature</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RungeKuttaConvolutionQuadrature{T,N,NN}</code></pre><p>T: the value type of the basis function. N: the number of stages. NN: N*N.</p><p>Performs a convolution quadrature on a laplaceKernel to represent an operator in time domain using an implicit Runge-Kutta method.</p><p>laplaceKernel: function of the Laplace variable s that returns an IntegralOperator. A, b: Coefficient matrix and vectors from the Butcher tableau. Δt: time step. zTransformedTermCount: Number of terms in the inverse Z-transform. contourRadius: radius of circle used as integration contour for the inverse Z-transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/timedomain/rkcq.jl#L3-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.SingleLayerTrace"><a class="docstring-binding" href="#BEAST.SingleLayerTrace"><code>BEAST.SingleLayerTrace</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Describe a single layer operator from the surface to a line.</p><p class="math-container">\[&lt;v, Su&gt; = ∫_γ dx v(x) ∫_Γ dy rac{e^{-ikR}}{4πR} u(y)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/nitsche.jl#L3-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.StagedTimeStep"><a class="docstring-binding" href="#BEAST.StagedTimeStep"><code>BEAST.StagedTimeStep</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StagedTimeStep{T,N,NN}</code></pre><p>T: the value type of the basis function. N: the number of stages. NN: the number of stages squared Each time step has intermediary stages given by the vertor c in a Butcher tableau (A,b,c)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/stagedtimestep.jl#L4-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.TimeBasisDeltaShifted"><a class="docstring-binding" href="#BEAST.TimeBasisDeltaShifted"><code>BEAST.TimeBasisDeltaShifted</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TimeBasisDeltaShifted{T}</code></pre><p>Represents a TimeBasisDelta{T} retarded by a fraction of the time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/timebasis.jl#L378-L382">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.TimeBasisFunction"><a class="docstring-binding" href="#BEAST.TimeBasisFunction"><code>BEAST.TimeBasisFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TimeBasisFunction{N,D}</code></pre><p>T: the value type of the time basis function N: the number of intervals in the support (this included the semi infinite interval     stretching to +∞) D1: the degree of the TBF restricted to each of the intervals <strong>plus one</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/timebasis.jl#L17-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.VIEFarField3D"><a class="docstring-binding" href="#BEAST.VIEFarField3D"><code>BEAST.VIEFarField3D</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Operator to compute the far field of a current distribution. In particular, given the current distribution <span>$j$</span> this operator allows for the computation of</p><p class="math-container">\[A j = n × ∫_Ω j e^{γ x ⋅ y} dy\]</p><p>where <span>$x$</span> is the unit vector in the direction of observation. Note that the assembly routing expects the observation directions to be normalised by the caller.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/volumeintegral/farfield.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST._trace-Tuple{BEAST.Kernel, Any, Any}"><a class="docstring-binding" href="#BEAST._trace-Tuple{BEAST.Kernel, Any, Any}"><code>BEAST._trace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_trace(kernel,interior,Val{N})

computes the jump contribution of a kernel, where N is the dimension of the potential integral.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/composedoperators/trace.jl#L15-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.assemble-Tuple{BEAST.AbstractOperator, Any, Any}"><a class="docstring-binding" href="#BEAST.assemble-Tuple{BEAST.AbstractOperator, Any, Any}"><code>BEAST.assemble</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assemble(operator, test_functions, trial_functions;
    storage_policy = Val{:bandedstorage},
    threading = :dofsplitting,
    scheduler = OhMyThreads.DynamicScheduler(),
    quadstrat=defaultquadstrat(operator, test_functions, trial_functions))</code></pre><p>Assemble the system matrix corresponding to the operator <code>operator</code> tested with the test functions <code>test_functions</code> and the trial functions <code>trial_functions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/operator.jl#L91-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.assemble-Tuple{BEAST.Functional, Any}"><a class="docstring-binding" href="#BEAST.assemble-Tuple{BEAST.Functional, Any}"><code>BEAST.assemble</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assemble(fn, tfs)</code></pre><p>Assemble the vector of test coefficients corresponding to functional <code>fn</code> and test functions <code>tfs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/excitation.jl#L11-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.assemble_local_mixed!-Union{Tuple{T}, Tuple{BEAST.LocalOperator, BEAST.Space{T}, BEAST.Space{T}, Any}} where T"><a class="docstring-binding" href="#BEAST.assemble_local_mixed!-Union{Tuple{T}, Tuple{BEAST.LocalOperator, BEAST.Space{T}, BEAST.Space{T}, Any}} where T"><code>BEAST.assemble_local_mixed!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assemble_local_mixed(biop::LocalOperator, tfs, bfs)</code></pre><p>For use when basis and test functions are defined on different meshes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/localop.jl#L281-L285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.assemblechunk!-Tuple{BEAST.IntegralOperator, BEAST.Space, BEAST.Space, Any}"><a class="docstring-binding" href="#BEAST.assemblechunk!-Tuple{BEAST.IntegralOperator, BEAST.Space, BEAST.Space, Any}"><code>BEAST.assemblechunk!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assemblechunk!(biop::IntegralOperator, tfs, bfs, store)</code></pre><p>Computes the matrix of operator biop wrt the finite element spaces tfs and bfs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/integralop.jl#L64-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.assemblydata-Tuple{BEAST.Space}"><a class="docstring-binding" href="#BEAST.assemblydata-Tuple{BEAST.Space}"><code>BEAST.assemblydata</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">charts, admap, act_to_global = assemblydata(basis; onlyactives=true)</code></pre><p>Given a <code>basis</code> this function returns a data structure containing the information required for matrix assemble, that is, the vector <code>charts</code> containing <code>Simplex</code> elements, a variable <code>admap</code> of type <code>AssemblyData</code>, and a mapping from indices of actively used simplices to global simplices.</p><p>When <code>onlyactives</code> is <code>true</code>, another layer of indices is introduced to filter out all cells of the mesh that are not in the union of the support of the basis functions (i.e., when the basis functions are defined only on a part of the mesh).</p><p><code>admap</code> is, in essence, a three-dimensional array of named tuples, which, by wrapping it in the struct <code>AssemblyData</code>, allows the definition of iterators. The tuple consists of the two entries</p><pre><code class="language-julia hljs">admap[i,r,c].globalindex
admap[i,r,c].coefficient</code></pre><p>Here, <code>c</code> and <code>r</code> are indices in the iterable set of (active) simplices and the set of shape functions on each cell/simplex: <code>r</code> ranges from 1 to the number of shape functions on a cell/simplex, <code>c</code> ranges from 1 to the number of active simplices, and <code>i</code> ranges from 1 to the number of maximal number of basis functions, where any of the shape functions contributes to. </p><p>For example, for continuous piecewise linear lagrange functions (c0d1), each of the three shape functions on a triangle are associated with exactly one Lagrange function, and therefore <code>i</code> is limited to 1.</p><p><em>Note</em>: When <code>onlyactives=false</code>, the indices <code>c</code> correspond to the position of the corresponding cell/simplex whilst iterating over <code>geometry(basis)</code>. When <code>onlyactives=true</code>, then <code>act_to_global(c)</code> correspond to the position of the corresponding cell/simplex whilst iterating over <code>geometry(basis)</code>.</p><p>For a triplet <code>(i,r,c)</code>, <code>globalindex</code> is the index in the <code>basis</code> of the <code>i</code>th basis function that has a contribution from shape function <code>r</code> on (active) cell/simplex <code>c</code>. <code>coefficient</code> is the coefficient of that contribution in the linear combination defining that basis function in terms of shape function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/basis.jl#L164-L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.basisfunction-Tuple{BEAST.Space, Any}"><a class="docstring-binding" href="#BEAST.basisfunction-Tuple{BEAST.Space, Any}"><code>BEAST.basisfunction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">basisfunction(basis, i)</code></pre><p>Returns a vector of the shape functions defining the <code>i</code>th function of the <code>basis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/basis.jl#L58-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.blockassembler"><a class="docstring-binding" href="#BEAST.blockassembler"><code>BEAST.blockassembler</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">blockassembler(operator, test_space, trial_space) -&gt; assembler</code></pre><p>Return a callable object for the creation of blocks within a BEM matrix.</p><p>This function performs all tasks common to the assembly of several blocks within a single boundary element matrix. The return value can be used to generate blocks by calling it as follows:</p><pre><code class="language-julia hljs">assembler(I,J,storefn)</code></pre><p>where <code>I</code> and <code>J</code> are arrays of indices in <code>test_space</code> and <code>trial_space</code>, respectively, corresponding to the rows and columns of the desired block.</p><p>Note that the block will be constructed in compressed form, i.e. the rows and columns of the store that are written into are the positions within <code>I</code> and <code>J</code> (as opposed to the positions within <code>1:numfunctions(test_space)</code> and <code>1:numfunctions(trial_space)</code>). In particular the size of the constructed block will be <code>(length(I), length(J))</code>.</p><p>This last property allows the assembly of permutations of the BEM matrix by supplying for <code>I</code> and <code>J</code> permutations of <code>1:numfunctions(test_space)</code> and <code>1:numfunctions(trial_space)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/integralop.jl#L6-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.buffachristiansen"><a class="docstring-binding" href="#BEAST.buffachristiansen"><code>BEAST.buffachristiansen</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">buffachristiansen(Γ, γ)</code></pre><p>Construct the set of Buffa-Christiansen functions subject to mesh Γ and only enforcing zero normal components on ∂Γ ∖ γ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/bcspace.jl#L84-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.buildhalfbc-NTuple{6, Any}"><a class="docstring-binding" href="#BEAST.buildhalfbc-NTuple{6, Any}"><code>BEAST.buildhalfbc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">buildhalfbc(fine, supp::Array{SVector{3,Int},1}, v, p)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/bcspace.jl#L191-L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.butcher_tableau_radau_2stages-Tuple{}"><a class="docstring-binding" href="#BEAST.butcher_tableau_radau_2stages-Tuple{}"><code>BEAST.butcher_tableau_radau_2stages</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">butcher_tableau_radau_2stages()</code></pre><p>Returns (A,b,c) corresponding to the Butcher tableau for the 2 stage Radau IIA scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/utils/butchertableau.jl#L5-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.butcher_tableau_radau_3stages-Tuple{}"><a class="docstring-binding" href="#BEAST.butcher_tableau_radau_3stages-Tuple{}"><code>BEAST.butcher_tableau_radau_3stages</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">butcher_tableau_radau_3stages()</code></pre><p>Returns (A,b,c) corresponding to the Butcher tableau for the 3 stage Radau IIA scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/utils/butchertableau.jl#L18-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.curl-Tuple{BEAST.Space}"><a class="docstring-binding" href="#BEAST.curl-Tuple{BEAST.Space}"><code>BEAST.curl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">curl(X)</code></pre><p>Compute the curl of a finite element basis. The resulting set of functions might be linearly dependent because of the kernel of the curl operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/divergence.jl#L31-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.dipolemw3d-Tuple{}"><a class="docstring-binding" href="#BEAST.dipolemw3d-Tuple{}"><code>BEAST.dipolemw3d</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dipolemw3d(;location, orientation, wavenumber)</code></pre><p>Create an electric dipole solution to Maxwell&#39;s equations representing the electric field part. Implementation is based on (9.18) of Jackson&#39;s “Classical electrodynamics”, with the notable difference that the <span>$\exp(ikr)$</span> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/mwexc.jl#L125-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.divergence-Tuple{BEAST.Space}"><a class="docstring-binding" href="#BEAST.divergence-Tuple{BEAST.Space}"><code>BEAST.divergence</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">divergence(x)</code></pre><p>Compute the divergence of a finite element space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/divergence.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.duallagrangec0d1-Tuple{Any, Any, Any, Type{Val{2}}}"><a class="docstring-binding" href="#BEAST.duallagrangec0d1-Tuple{Any, Any, Any, Type{Val{2}}}"><code>BEAST.duallagrangec0d1</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">duallagrangec0d1(originalmesh, refinedmesh)</code></pre><p>It is the user responsibility to provide two meshes representing the same object. The second mesh needs to be obtained using &quot;barycentric_refinement(originalmesh)&quot;. This basis function creats the dual Lagrange basis function and return an object that contains array of shapes [fns] It also return a gemoetry containing the refined mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/lagrange.jl#L723-L730">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.duallagrangecxd0"><a class="docstring-binding" href="#BEAST.duallagrangecxd0"><code>BEAST.duallagrangecxd0</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">duallagrangecxd0(mesh, jct) -&gt; basis</code></pre><p>Build dual Lagrange piecewise constant elements. Boundary nodes are only considered if they are in the interior of <code>jct</code>.</p><p>The default dual function (<code>interpolatory=false</code>) is similar to the one depicted in Figure 3 of  Buffa et al (doi: 10.1090/S0025-5718-07-01965-5), with the difference that each individual shape function is normalized with respect to  the area so that overall the integral over the dual function is one.</p><p>When <code>interpolatory=true</code> is used, the function value is one on the support, and thus, it gives rise to a partition of unity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/lagrange.jl#L253-L266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.elements-Tuple{Any}"><a class="docstring-binding" href="#BEAST.elements-Tuple{Any}"><code>BEAST.elements</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>elements(geo)</p><p>Create an iterable collection of the elements stored in <code>geo</code>. The order in which this collection produces the elements determines the index used for lookup in the data structures returned by <code>assemblydata</code> and <code>quaddata</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/integralop.jl#L53-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.extend-Union{Tuple{S}, Tuple{S, CompScienceMeshes.SubMesh, Any}} where S&lt;:BEAST.Space"><a class="docstring-binding" href="#BEAST.extend-Union{Tuple{S}, Tuple{S, CompScienceMeshes.SubMesh, Any}} where S&lt;:BEAST.Space"><code>BEAST.extend</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extend(submesh, parentmesh)</code></pre><p>Extend functions defined on a submesh to their extension by zero on the parent mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/restrict.jl#L32-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.facecurrents-Tuple{Any, Any}"><a class="docstring-binding" href="#BEAST.facecurrents-Tuple{Any, Any}"><code>BEAST.facecurrents</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fcr, geo = facecurrents(coeffs, basis)</code></pre><p>Compute the value of the function with the given collection of coeffient in the provided basis in all the centroids of the mesh underlying the basis. The mesh is returned together with the currents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/postproc.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.gamma_wavenumber_handler-Tuple{Any, Any}"><a class="docstring-binding" href="#BEAST.gamma_wavenumber_handler-Tuple{Any, Any}"><code>BEAST.gamma_wavenumber_handler</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gamma_wavenumber_handler(gamma, wavenumber)</code></pre><p>This function handles the input of <code>gamma</code> and <code>wavenumber</code>. It throws an error if both <code>gamma</code> and <code>wavenumber</code> are provided. If neither is provided, it assumes a static problem and returns <code>Val(0)</code> for <code>gamma</code> and <code>wavenumber</code>.</p><p><strong>Arguments</strong></p><ul><li><code>gamma</code>: <code>im</code> * <code>wavenumber</code> or <code>nothing</code>.</li><li><code>wavenumber</code>: <code>wavenumber</code> or <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>gamma</code> and <code>wavenumber</code>: Appropriate pair <code>gamma</code> and <code>wavenumber</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/mwops.jl#L199-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.geometry-Tuple{BEAST.Space}"><a class="docstring-binding" href="#BEAST.geometry-Tuple{BEAST.Space}"><code>BEAST.geometry</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">geometry(basis)</code></pre><p>Returns an iterable collection of geometric elements on which the functions in <code>basis</code> are defined. The order the elements are encountered needs correspond to the element indices used in the data structure returned by <code>assemblydata</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/basis.jl#L49-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.getcommonedge-Tuple{Any, Any}"><a class="docstring-binding" href="#BEAST.getcommonedge-Tuple{Any, Any}"><code>BEAST.getcommonedge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getcommonedge(cell1, cell2) -&gt; e1, e2, edge</code></pre><p>Returns in edge the common vertices of cell1 and cell2. e1 contains the index of the vertex of cell1 opposite to this common edge, and with a plus or minus sign depending on whether the orientation of the common edge is along or against the internal orientation of cell1. Similar for e2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/utils/combinatorics.jl#L32-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.getindex_rtg-Tuple{BEAST.RTBasis}"><a class="docstring-binding" href="#BEAST.getindex_rtg-Tuple{BEAST.RTBasis}"><code>BEAST.getindex_rtg</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex_rtg(RT::RTBasis)</code></pre><p>Returns the indices of the global half RWGs present in <code>RT</code>. <code>RT</code> is typically gotten from <code>rt_ports</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/rtspace.jl#L244-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.grideval-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#BEAST.grideval-Tuple{Any, Any, Any}"><code>BEAST.grideval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">grideval(points, coeffs, basis; type=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/postproc/segcurrents.jl#L19-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.hh2d_makegammacomplexifneeded-Tuple{Real}"><a class="docstring-binding" href="#BEAST.hh2d_makegammacomplexifneeded-Tuple{Real}"><code>BEAST.hh2d_makegammacomplexifneeded</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hh2d_makegammacomplexifneeded(gamma)</code></pre><p>Returns a complexified gamma. Unlike the 3D-case, the handling of the Green&#39;s function is more complicated as, for example, the static kernel is not the limit of the dynamic kernel for k → 0</p><p>First, recall that throughout BEAST, we assume a dependency of exp(+iωt). The wavenumber k and gamma are related via  γ = ik (and thus k = -iγ). Accordingly, the homogeneous 2D Helmholtz equation reads     - Δu - k² u = - Δu + γ² u = 0</p><p>For physically meaning full real gamma (i.e., γ &gt;= 0), the solutions of the BIEs are real-valued. For this reason, we will use gamma and not k to  deduce the underlying scalartype of the operator.</p><p>Note that if γ &lt; 0 – eventhough it is real valued – the fundamental solution is no longer the modified Bessel function K, and instead we have to resort to the general solution, the Hankel function (i.e., we could use the Hankel function for γ &gt; 0, but it is slower than then modified Bessel function)</p><p>The Green&#39;s functions are:</p><p>2D Laplace:     G(x, y) = -1/(2π)* ln|x - y|</p><p>2D modified Helmholtz equation:     G(x, y) = 1/(2π)* K₀(γ |x - y|)</p><p>2D Helmholtz equation     G(x, y) = -i/4 * H₀⁽²⁾(-iγ |x - y|) where γ = ik (and thus k = -iγ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/helmholtz2d/hh2dops.jl#L19-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.index_actives-Tuple{Any, Any}"><a class="docstring-binding" href="#BEAST.index_actives-Tuple{Any, Any}"><code>BEAST.index_actives</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">active, index_among_actives, num_active_cells, act_to_global =
    index_actives(num_cells, celltonum)</code></pre><p>Given the number of cells of the mesh <code>num_cells</code> and an array indicating, which shape functions of each cell are used in the definition of the basis, <code>celltonum</code>, <code>index_actives(num_cells, celltonum)</code> computes a Boolean vector <code>active</code> that indicates for each cell index if the cell is in the support of any basis function. For this reduced set of active cells, a new index set is introduced, where <code>index_among_actives</code> is a vector providing the mapping from the cells of the mesh to the indices of the active cells, <code>num_active_cells</code> provides the number of all active cells, and <code>act_to_global</code> is a vector providing the mapping from the indices of the active cells to the indices of cells of the underlying mesh of the basis function spce.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/basis.jl#L287-L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.indices_splitfemglobal-Union{Tuple{BEAST.LinearCombinationOfAbstractMeshFunctions{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#BEAST.indices_splitfemglobal-Union{Tuple{BEAST.LinearCombinationOfAbstractMeshFunctions{T}}, Tuple{T}} where T"><code>BEAST.indices_splitfemglobal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">indices_splitfemglobal(lincombgfs)</code></pre><p>Given a linear combination of FEMFunctions and/or GlobalFunctions, return the indices of the fem and the global functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/gridfunction.jl#L163-L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.instantiate_charts-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#BEAST.instantiate_charts-Tuple{Any, Any, Any}"><code>BEAST.instantiate_charts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">instantiate_charts(geo, num_active_cells, active)</code></pre><p>Returns a vector of all actively used simplices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/basis.jl#L319-L323">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.interpolate-Tuple{RefSpace, Any, RefSpace, Any}"><a class="docstring-binding" href="#BEAST.interpolate-Tuple{RefSpace, Any, RefSpace, Any}"><code>BEAST.interpolate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate(interpolant::RefSpace, chart1, interpolee::RefSpace, chart2)</code></pre><p>Computes by interpolation approximations of the local shape functions for <code>interpolee</code> on <code>chart2</code> in terms of the local shape functions for <code>interpolant</code> on <code>chart1</code>. The returned value is a matrix <code>Q</code> such that</p><p class="math-container">\[\phi_i \approx \sum_j Q_{ij} \psi_j\]</p><p>with <span>$\phi_i$</span> the i-th local shape function for <code>interpolee</code> and <span>$\psi_j$</span> the j-th local shape function for <code>interpolant</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/local/rtlocal.jl#L79-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.inverse_z_transform-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractVector{T}}} where T"><a class="docstring-binding" href="#BEAST.inverse_z_transform-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractVector{T}}} where T"><code>BEAST.inverse_z_transform</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inverse_z_transform(k, rho, N, X)</code></pre><p>Returns the k-th term of the inverse z-transform. X is an array of the z-transform evaluated in the points z=rho<em>exp(2</em>im<em>pi</em>n/N) for n in 0:(N-1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/timedomain/zdomain.jl#L15-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.isstatic-Tuple{Any}"><a class="docstring-binding" href="#BEAST.isstatic-Tuple{Any}"><code>BEAST.isstatic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isstatic(gamma)</code></pre><p>This function checks if the provided <code>gamma</code> value represents a static problem. It returns true if <code>gamma</code> is of type <code>Val{0}</code> indicating a static problem.</p><p><strong>Arguments</strong></p><ul><li><code>gamma</code>: <code>gamma</code> value.</li></ul><p><strong>Returns</strong></p><ul><li>A boolean indicating whether the problem is static or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/mwops.jl#L240-L251">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.lagdimension"><a class="docstring-binding" href="#BEAST.lagdimension"><code>BEAST.lagdimension</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>The dimension of the space of Lagrange shape functions of degree d over a simplex of dimension n is binom(n+d,d) == binom(n+d,n)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/lagrange.jl#L2-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.lagrangec0d1-Tuple{Any}"><a class="docstring-binding" href="#BEAST.lagrangec0d1-Tuple{Any}"><code>BEAST.lagrangec0d1</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lagrangec0d1(mesh; dirichlet=[true|false]) -&gt; basis</code></pre><p>Build lagrangec0d1 elements, including (dirichlet=false) or excluding (dirichlet=true) those attached to boundary vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/lagrange.jl#L331-L336">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.lagrangec0d1_dirichlet-Tuple{Any}"><a class="docstring-binding" href="#BEAST.lagrangec0d1_dirichlet-Tuple{Any}"><code>BEAST.lagrangec0d1_dirichlet</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lagrangec0d1(mesh[, bnd])</code></pre><p>Construct the basis of continuous, piecewise linear basis functions subordinate to mesh <code>mesh</code>. Basis functions are constructed at vertices in the interior of the mesh and on the closure of &#39;bnd&#39;. In particular, leaving out the second argument creates a finite element space subject to homogeneous Dirichlet boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/lagrange.jl#L177-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.laplace_to_z-NTuple{6, Any}"><a class="docstring-binding" href="#BEAST.laplace_to_z-NTuple{6, Any}"><code>BEAST.laplace_to_z</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">laplace_to_z(rho, n, N, dt, A, b)</code></pre><p>Returns the complex matrix valued Laplace variable s that correspond to the variable z = rho<em>exp(2</em>im<em>pi</em>n/N) for a given Butcher tableau (A,b,c) and a time step dt.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/timedomain/zdomain.jl#L3-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.linearpotentialvie-Tuple{}"><a class="docstring-binding" href="#BEAST.linearpotentialvie-Tuple{}"><code>BEAST.linearpotentialvie</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>linearpotentialvie(;     direction    = error(&quot;missing argument <code>direction</code>&quot;),     amplitude    = 1,   )</p><p>Linear potential for volume integral equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/volumeintegral/vieexc.jl#L80-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.localindices-Tuple{BEAST._LagrangeGlobalNodesDoFs, CompScienceMeshes.Simplex, Any, Any}"><a class="docstring-binding" href="#BEAST.localindices-Tuple{BEAST._LagrangeGlobalNodesDoFs, CompScienceMeshes.Simplex, Any, Any}"><code>BEAST.localindices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">localindices(dof, chart, i)</code></pre><p>Returns a vector of indices into the vector of local shape functions that correspond to global degrees of freedom supported on sub-entity <code>i</code>, where the type of entity (nodes, edge, face) is encoded in the type of &#39;dof&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/lagrange.jl#L1223-L1229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.make_celltonum-NTuple{4, Any}"><a class="docstring-binding" href="#BEAST.make_celltonum-NTuple{4, Any}"><code>BEAST.make_celltonum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">celltonum = make_celltonum(num_cells, num_refs, num_bfs, basis)</code></pre><p>Computes the array <code>celltonum[c,r]</code> that, given the index <code>c</code> of a cell of the mesh associated with the <code>basis</code> and the index <code>r</code> of the shape function in the refspace associated with <code>basis</code>, provides the number of basis functions where the <code>r</code>th shape function on cell <code>c</code> is used in their definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/basis.jl#L266-L273">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.marchonintime-NTuple{4, Any}"><a class="docstring-binding" href="#BEAST.marchonintime-NTuple{4, Any}"><code>BEAST.marchonintime</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">marchonintime(W0,Z,B,I; convhist=false)</code></pre><p>Solve by marching-on-in-time the causal convolution problem defined by <code>(W0,Z,B)</code> up to timestep <code>I</code>. Here, <code>Z</code> is an array of order 3 that contains a discretisation of a time translation invariant retarded potential operator. <code>W0</code> is the inverse of the slice <code>Z[:,:,1]</code>.</p><p>Keyword arguments:     - &#39;convhist&#39;: when true, return in addition to the space-time data for the     solution also the vector of convergence histories as returned each time step     by the supplied solver <code>W0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/timedomain/motlu.jl#L19-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.momintegrals!-Tuple{Any, Any, Any, Any, Any, Any, BEAST.DoubleQuadRule}"><a class="docstring-binding" href="#BEAST.momintegrals!-Tuple{Any, Any, Any, Any, Any, Any, BEAST.DoubleQuadRule}"><code>BEAST.momintegrals!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>momintegrals!(biop, tshs, bshs, tcell, bcell, interactions, strat)</p><p>Function for the computation of moment integrals using simple double quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/quadrature/doublenumints.jl#L7-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.move_after!-NTuple{4, Any}"><a class="docstring-binding" href="#BEAST.move_after!-NTuple{4, Any}"><code>BEAST.move_after!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Move the s-th element right after the d-th</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/bcspace.jl#L3-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.nedelec2"><a class="docstring-binding" href="#BEAST.nedelec2"><code>BEAST.nedelec2</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nedelec2(mesh, edges)</code></pre><p>Constructs the 2nd degree Nedelec basis of the first kind i.e. H(curl).</p><p>Returns an object of type &#39;ND2Basis&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/nd2space.jl#L11-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.ntrace-Tuple{BEAST.RTRefSpace, Any, Any, Any}"><a class="docstring-binding" href="#BEAST.ntrace-Tuple{BEAST.RTRefSpace, Any, Any, Any}"><code>BEAST.ntrace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ntrace(refspace, element, localindex, face)</code></pre><p>Compute the normal trace of all local shape functions on <code>elements</code> belonging to <code>refspace</code> on <code>face</code>. This function returns a matrix expressing the traces of local shape functions in <code>refspace</code> as linear combinations of functions in the local trace space. Cf. <code>restrict</code>. <code>localindex</code> is the index of <code>face</code> in the enumeration of faces of <code>elements</code>. In many special cases knowing this index allows for highly optimised implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/local/rtlocal.jl#L33-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.ntrace-Union{Tuple{T}, Tuple{BEAST.DirectProductSpace{T}, Any}} where T"><a class="docstring-binding" href="#BEAST.ntrace-Union{Tuple{T}, Tuple{BEAST.DirectProductSpace{T}, Any}} where T"><code>BEAST.ntrace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ntrace(X::Space, γ::Mesh)</code></pre><p>Compute the normal trace of basis X on mesh γ. γ is assumed to be part of the boundary of geometry(X).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/trace.jl#L3-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.numfunctions-Tuple{BEAST.Space}"><a class="docstring-binding" href="#BEAST.numfunctions-Tuple{BEAST.Space}"><code>BEAST.numfunctions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">numfunctions(basis)</code></pre><p>Number of functions in the basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/basis.jl#L66-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.planewave-NTuple{4, Any}"><a class="docstring-binding" href="#BEAST.planewave-NTuple{4, Any}"><code>BEAST.planewave</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">planewave(polarisation,direction,amplitude,speedoflight)</code></pre><p>Time-domain plane wave.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/timedomain/mwtdexc.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.planewavemw3d-Tuple{}"><a class="docstring-binding" href="#BEAST.planewavemw3d-Tuple{}"><code>BEAST.planewavemw3d</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">planewavemw3d(;direction, polarization, wavenumber, gamma[, amplitude=1])</code></pre><p>Create a plane wave solution to Maxwell&#39;s equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/mwexc.jl#L16-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.planewavevie-Tuple{}"><a class="docstring-binding" href="#BEAST.planewavevie-Tuple{}"><code>BEAST.planewavevie</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>planewavevie(;       direction    = error(&quot;missing arguement <code>direction</code>&quot;),       polarization = error(&quot;missing arguement <code>polarization</code>&quot;),       wavenumber   = error(&quot;missing arguement <code>wavenumber</code>&quot;),       amplitude    = 1,       ) </p><p>For volume integral equations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/volumeintegral/vieexc.jl#L16-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.portcells-Tuple{Any, Any}"><a class="docstring-binding" href="#BEAST.portcells-Tuple{Any, Any}"><code>BEAST.portcells</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">portcells(Γ::Mesh, γ::Mesh)</code></pre><p>returns an array containing cell pairs of mesh Γ around a boundary edge that overlaps with mesh γ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/rtspace.jl#L135-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.potential-NTuple{4, Any}"><a class="docstring-binding" href="#BEAST.potential-NTuple{4, Any}"><code>BEAST.potential</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">potential(op, points, coeffs, basis)</code></pre><p>Evaluate operator for a given bases and expansion coefficients at the given points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/postproc.jl#L133-L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.qh-Union{Tuple{T}, Tuple{N}, Tuple{Type{T}, Any, Type{Val{N}}}} where {N, T}"><a class="docstring-binding" href="#BEAST.qh-Union{Tuple{T}, Tuple{N}, Tuple{Type{T}, Any, Type{Val{N}}}} where {N, T}"><code>BEAST.qh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Q = qd(T,dh,::Val{N})</code></pre><p>Q[k] is the factor in front resulting from differentiating t^(k-1) dh times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/timedomain/mwtdops.jl#L197-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.quaddata"><a class="docstring-binding" href="#BEAST.quaddata"><code>BEAST.quaddata</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">quaddata(operator, test_refspace, trial_refspace, test_elements, trial_elements)</code></pre><p>Returns an object cashing data required for the computation of boundary element interactions. It is up to the client programmer to decide what (if any) data is cached. For double numberical quadrature, storing the integration points for example can significantly speed up matrix assembly.</p><ul><li><code>operator</code> is an integration kernel.</li><li><code>test_refspace</code> and <code>trial_refspace</code> are reference space objects. <code>quadata</code></li></ul><p>is typically overloaded on the type of these local spaces of shape functions. (See the implementation in <code>maxwell.jl</code> for an example).</p><ul><li><code>test_elements</code> and <code>trial_elements</code> are iterable collections of the geometric</li></ul><p>elements on which the finite element space are defined. These are provided to allow computation of the actual integrations points - as opposed to only their coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/quadrature/quadstrats.jl#L72-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.quadrule"><a class="docstring-binding" href="#BEAST.quadrule"><code>BEAST.quadrule</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">quadrule(operator, test_refspace, trial_refspace, test_index, test_chart, trial_index, trial_chart, quad_data)</code></pre><p>Based on the operator kernel and the test and trial elements, this function builds an object whose type and data fields specify the quadrature rule that needs to be used to accurately compute the interaction integrals. The <code>quad_data</code> object created by <code>quaddata</code> is passed to allow reuse of any precomputed data such as quadrature points and weights, geometric quantities, etc.</p><p>The type of the returned quadrature rule will help in deciding which method of <code>momintegrals</code> to dispatch to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/quadrature/quadstrats.jl#L92-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.quadrule-Tuple{BEAST.BoundaryOperator, RefSpace, RefSpace, Any, CompScienceMeshes.Simplex{&lt;:Any, 2, &lt;:Any, 3}, Any, CompScienceMeshes.Simplex{&lt;:Any, 3, &lt;:Any, 4}, Any, BEAST.SauterSchwab3DQStrat}"><a class="docstring-binding" href="#BEAST.quadrule-Tuple{BEAST.BoundaryOperator, RefSpace, RefSpace, Any, CompScienceMeshes.Simplex{&lt;:Any, 2, &lt;:Any, 3}, Any, CompScienceMeshes.Simplex{&lt;:Any, 3, &lt;:Any, 4}, Any, BEAST.SauterSchwab3DQStrat}"><code>BEAST.quadrule</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>triangle-tetrahedron quadrule for the 5D integral ∫∫<em>Γ ∫∫∫</em>Ω</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/volumeintegral/vieops.jl#L534-L536">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.quadrule-Tuple{BEAST.BoundaryOperator, RefSpace, RefSpace, Any, CompScienceMeshes.Simplex{&lt;:Any, 3, &lt;:Any, 4}, Any, CompScienceMeshes.Simplex{&lt;:Any, 2, &lt;:Any, 3}, Any, BEAST.SauterSchwab3DQStrat}"><a class="docstring-binding" href="#BEAST.quadrule-Tuple{BEAST.BoundaryOperator, RefSpace, RefSpace, Any, CompScienceMeshes.Simplex{&lt;:Any, 3, &lt;:Any, 4}, Any, CompScienceMeshes.Simplex{&lt;:Any, 2, &lt;:Any, 3}, Any, BEAST.SauterSchwab3DQStrat}"><code>BEAST.quadrule</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>tetrahedron-triangle quadrule for the 5D integral ∫∫∫<em>Ω ∫∫</em>Γ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/volumeintegral/vieops.jl#L560-L562">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.quadrule-Tuple{BEAST.VolumeOperator, RefSpace, RefSpace, Any, CompScienceMeshes.Simplex{&lt;:Any, 3, &lt;:Any, 4}, Any, CompScienceMeshes.Simplex{&lt;:Any, 3, &lt;:Any, 4}, Any, BEAST.SauterSchwab3DQStrat}"><a class="docstring-binding" href="#BEAST.quadrule-Tuple{BEAST.VolumeOperator, RefSpace, RefSpace, Any, CompScienceMeshes.Simplex{&lt;:Any, 3, &lt;:Any, 4}, Any, CompScienceMeshes.Simplex{&lt;:Any, 3, &lt;:Any, 4}, Any, BEAST.SauterSchwab3DQStrat}"><code>BEAST.quadrule</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>tetrahedron-tetrahedron quadrule for the 6D integral ∫∫∫<em>Ω ∫∫∫</em>Ω </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/volumeintegral/vieops.jl#L506-L508">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.raviartthomas-Tuple{Any}"><a class="docstring-binding" href="#BEAST.raviartthomas-Tuple{Any}"><code>BEAST.raviartthomas</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">raviartthomas(mesh)</code></pre><p>Conducts pre-processing on the input <code>mesh</code> by extracting the cell edges, cell pairs     and indices required to construct the RT basis on the <code>mesh</code>.</p><p>Calls raviartthomas(mesh::Mesh, cellpairs::Array{Int,2}), which constructs     the RT basis on the <code>mesh</code>, using the cell pairs identified.</p><p>Returns the RT basis object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/rtspace.jl#L89-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.raviartthomas-Union{Tuple{T}, Tuple{D1}, Tuple{U}, Tuple{CompScienceMeshes.AbstractMesh{U, D1, T}, Matrix{Int64}}} where {U, D1, T}"><a class="docstring-binding" href="#BEAST.raviartthomas-Union{Tuple{T}, Tuple{D1}, Tuple{U}, Tuple{CompScienceMeshes.AbstractMesh{U, D1, T}, Matrix{Int64}}} where {U, D1, T}"><code>BEAST.raviartthomas</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">raviartthomas(mesh, cellpairs::Array{Int,2})</code></pre><p>Constructs the RT basis on the input <code>mesh</code>. The i-th RT basis function will     represent a current distribution flowing from cell <code>cellpairs[1,i]</code> to     <code>cellpairs[2,i]</code> on the mesh.</p><p>Returns an object of type <code>RTBasis</code>, which comprises both the mesh and pairs of     Shape objects which corresponds to the cell pairs, containing the necsessary     coefficients and indices to compute the exact basis functions when required     by the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/rtspace.jl#L23-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.raviartthomas2-Tuple{Any}"><a class="docstring-binding" href="#BEAST.raviartthomas2-Tuple{Any}"><code>BEAST.raviartthomas2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">raviartthomas2(mesh)</code></pre><p>Conducts pre-processing on the input <code>mesh</code> by extracting the cell edges, cell pairs     and indices required to construct the RT2 basis on the <code>mesh</code>.</p><p>Calls raviartthomas2(mesh::Mesh, cellpairs::Array{Int,2}), which constructs     the RT2 basis on the <code>mesh</code>, using the cell pairs identified.</p><p>Returns the RT2 basis object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/rt2space.jl#L104-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.raviartthomas2-Union{Tuple{T}, Tuple{D1}, Tuple{U}, Tuple{CompScienceMeshes.AbstractMesh{U, D1, T}, Matrix{Int64}}} where {U, D1, T}"><a class="docstring-binding" href="#BEAST.raviartthomas2-Union{Tuple{T}, Tuple{D1}, Tuple{U}, Tuple{CompScienceMeshes.AbstractMesh{U, D1, T}, Matrix{Int64}}} where {U, D1, T}"><code>BEAST.raviartthomas2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">raviartthomas2(mesh, cellpairs::Array{Int,2})</code></pre><p>Constructs the RT2 basis on the input <code>mesh</code>. The i-th RT2 basis function will     represent a current distribution flowing from cell <code>cellpairs[1,i]</code> to     <code>cellpairs[2,i]</code> on the mesh.</p><p>Returns an object of type <code>RT2Basis</code>, which comprises both the mesh and pairs of     Shape objects which corresponds to the cell pairs, containing the necsessary     coefficients and indices to compute the exact basis functions when required     by the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/rt2space.jl#L19-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.real_inverse_z_transform-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractVector{T}}} where T"><a class="docstring-binding" href="#BEAST.real_inverse_z_transform-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractVector{T}}} where T"><code>BEAST.real_inverse_z_transform</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">real_inverse_z_transform(k, rho, N, X)</code></pre><p>Returns the k-th term of the inverse z-transform. It is assumed that X[n+1] = conj(X[N-n]) for each n in 1:(N-1) so that Nmax = N/2+1 or (N+1)/2 (resp. if N%2==0 or N%2==1) terms are used in X X is an array of the z-transform evaluated in the points z=rho<em>exp(2</em>im<em>pi</em>n/N) for n in 0:(Nmax-1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/timedomain/zdomain.jl#L25-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.refspace"><a class="docstring-binding" href="#BEAST.refspace"><code>BEAST.refspace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">refspace(basis)</code></pre><p>Returns the ReferenceSpace of local shape functions on which the basis is built.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/basis.jl#L19-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.restrict"><a class="docstring-binding" href="#BEAST.restrict"><code>BEAST.restrict</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">restrict(refspace, element1, element2)</code></pre><p>Computes the restriction of a set of local shape functions on <code>element1</code> as linear combinations of the set of local shape functions on <code>element2</code>. More precisely <code>restrict</code> returns an <code>NxM</code> matrix <code>P</code> such that the <code>i</code>-th local shape <span>$g_i$</span> function on element2 can be written as:</p><p><span>$g_i = sum_{j=1}^{M} P_{ij} f_j$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/restrict.jl#L3-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.rt_cedge-Tuple{Matrix{Int64}, Any}"><a class="docstring-binding" href="#BEAST.rt_cedge-Tuple{Matrix{Int64}, Any}"><code>BEAST.rt_cedge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rt_cedge(cps::Array{Int,2}, weight)</code></pre><p>Computes single basis function with equally distributed constant current leaving or entering port defined by cellpairs cps.  weight defines the total current over the port and its direction (+ve = out, -ve = in)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/rtspace.jl#L154-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.rt_ports-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#BEAST.rt_ports-Tuple{Any, Vararg{Any}}"><code>BEAST.rt_ports</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rt_ports(Γ::Mesh, γ::Mesh ...)</code></pre><p>Constructs the RT space on <code>Γ</code>, relative to boundary pairs in <code>γ</code>. <code>γ</code> expects any number of pairs-of-ports as arguments and accepts tuples, arrays, vectors etc. e.g <code>rt_ports(Γ, a, b ...);</code> where a = [γ₁ γ₂], b = (γ₃,γ₄) etc. <code>rt_ports</code> with no pair of ports supplied i.e <code>rt_ports(Γ)</code> reduces to the <code>raviartthomas(Γ)</code> function. The RT space ensures current continuity in each pair of ports. i.e. current leaving mesh Γ through γ₁ is accounted for in γ₂.</p><p>Returns the RT basis object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/rtspace.jl#L202-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.rt_vedge-Tuple{Matrix{Int64}, Any}"><a class="docstring-binding" href="#BEAST.rt_vedge-Tuple{Matrix{Int64}, Any}"><code>BEAST.rt_vedge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rt_vedge(cps::Array{Int,2}, weight)</code></pre><p>Computes n-1 basis function with oscillating current in(leaving and entering) pairs of half triangles defined over port specified by cellpairs cps. weight defines the magnitude of individual current in and out the half triangles, and it&#39;s polarity simply defines whether to start with in or out</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/rtspace.jl#L176-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.saddlepoint-NTuple{4, SparseArrays.SparseMatrixCSC}"><a class="docstring-binding" href="#BEAST.saddlepoint-NTuple{4, SparseArrays.SparseMatrixCSC}"><code>BEAST.saddlepoint</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>saddlepoint(A,B,P1,P2) Create preconditioned saddlepoint matrix from A and B with block diagonal preconditoners [P1,P2]1 and P2. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/operators/projectors.jl#L34-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.scalartype"><a class="docstring-binding" href="#BEAST.scalartype"><code>BEAST.scalartype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">scalartype(x)</code></pre><p>The scalar field over which the values of a global or local basis function, or an operator are defined. This should always be a scalar type, even if the basis or operator takes on values in a vector or tensor space. This data type is used to determine the <code>eltype</code> of assembled discrete operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/basis.jl#L35-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.scalartype-Union{Tuple{RefSpace{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#BEAST.scalartype-Union{Tuple{RefSpace{T}}, Tuple{T}} where T"><code>BEAST.scalartype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scalartype(s)</code></pre><p>The scalar field over which the argument to a basis function or operator&#39;s integration kernel are defined. This is always a salar data type, even if the function or kernel is defined over a multi-dimensional space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/basis.jl#L9-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.singleduallagd0-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#BEAST.singleduallagd0-Tuple{Any, Any, Any}"><code>BEAST.singleduallagd0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">singleduallagd0(fine, F, v; interpolatory=false)</code></pre><p>Build a single dual constant Lagrange element a mesh <code>fine</code>. <code>F</code> contains the indices to cells in the support and v is the index in the vertex list of the defining vertex.</p><p>The default dual function (<code>interpolatory=false</code>) is similar to the one depicted in Figure 3 of  Buffa et al (doi: 10.1090/S0025-5718-07-01965-5), with the difference that each individual shape function is normalized with respect to the area so that overall the integral over the dual function is one.</p><p>When <code>interpolatory=true</code> is used, the function value is one on the support, and thus, it gives rise to a partition of unity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/lagrange.jl#L302-L315">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.solve-Tuple{Any}"><a class="docstring-binding" href="#BEAST.solve-Tuple{Any}"><code>BEAST.solve</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Solves a variational equation by simply creating the full system matrix and calling a traditional lu decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/solvers/lusolver.jl#L5-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.timebasisc0d1"><a class="docstring-binding" href="#BEAST.timebasisc0d1"><code>BEAST.timebasisc0d1</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timebasisc0d1(type, timestep, numfunctions)</code></pre><p>Build the space of continuous, piecewise linear time basis functions. The DoFs are the time steps. <code>numfunctions</code> basis functions will be built in total.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/timebasis.jl#L105-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.timebasiscxd0"><a class="docstring-binding" href="#BEAST.timebasiscxd0"><code>BEAST.timebasiscxd0</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timebasiscxd0(timestep, numfunctions, T::Type=Float64)</code></pre><p>Create a temporal basis based on shifted copies of the nodal continuous, piecewise linear interpolant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/timebasis.jl#L121-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.timebasisspline2"><a class="docstring-binding" href="#BEAST.timebasisspline2"><code>BEAST.timebasisspline2</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timebasisspline2(timestep, numfunctions, T::Type=Float64)</code></pre><p>Create a temporal basis based on shifted copies of the quadratic spline. The spline is the convolution of a cxd0 and a c0d1 basis function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/timebasis.jl#L137-L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.ttrace-Tuple{BEAST.NDLCDRefSpace, Any, Any, Any}"><a class="docstring-binding" href="#BEAST.ttrace-Tuple{BEAST.NDLCDRefSpace, Any, Any, Any}"><code>BEAST.ttrace</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Does not give the correct result for an imput basis with non-vanishing input basis on the boundary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/local/ndlcdlocal.jl#L41-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.unitfunctionc0d1-Tuple{Any}"><a class="docstring-binding" href="#BEAST.unitfunctionc0d1-Tuple{Any}"><code>BEAST.unitfunctionc0d1</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unitfunctionc0d1(mesh)</code></pre><p>Constructs a constant function with value 1 on <code>mesh</code> consisting of linear shapes. For dirichlet=true goes to zero on the boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/lagrange.jl#L81-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.unitfunctioncxd0-Tuple{Any}"><a class="docstring-binding" href="#BEAST.unitfunctioncxd0-Tuple{Any}"><code>BEAST.unitfunctioncxd0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unitfunctioncxd0(mesh)</code></pre><p>Constructs a constant function with value 1 on <code>mesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/bases/lagrange.jl#L52-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GraphsColoring.conflicts-Tuple{BEAST.Space}"><a class="docstring-binding" href="#GraphsColoring.conflicts-Tuple{BEAST.Space}"><code>GraphsColoring.conflicts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function conflicts(
    space::Space;
    addata=assemblydata(space),
    kwargs...,
)</code></pre><p>Computes conflict indices for a Space. Two elements are in conflict if they are both part of the support of the same basis function.</p><p><strong>Arguments</strong></p><ul><li><code>space::Space</code>: The space.</li><li><code>addata=assemblydata(space)</code>: The assembly data for the space (default: computed using <code>assemblydata</code>).</li><li><code>kwargs...</code>: Additional keyword arguments.</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ul><li><code>eachindex(elements)</code>: The indices of the elements.</li><li><code>ConflictFunctor(conflictindices)</code>: A functor that maps element indices to conflict indices.</li><li><code>Base.OneTo(numfunctions(space))</code>: The indices of the conflicts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/coloring.jl#L1-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.@discretise-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#BEAST.@discretise-Tuple{Any, Vararg{Any}}"><code>BEAST.@discretise</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">discr(eq, pairs...)</code></pre><p>This macro provides syntactical sugar for the definition of a discretisation of a varational formulation. Given a variational equation EQ: Find j ∈ X such that for all k ∈ Y a(k,j) = f(k) can be discretised by stating:</p><pre><code class="language-julia hljs">eq = @discretise EQ j∈X k∈Y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/solvers/solver.jl#L107-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.VIE.hhboundary-Tuple{}"><a class="docstring-binding" href="#BEAST.VIE.hhboundary-Tuple{}"><code>BEAST.VIE.hhboundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>hhboundary(;gamma, alpha, tau) hhboundary(;wavenumber, alpha, tau)</p><p>Bilinear form given by:</p><p class="math-container">\[    α ∬_{∂Ω×Ω} n̂(x) ⋅ j(x) G_{γ}(x,y) τ(y) (grad k(y))\]</p><p>with <span>$G_{γ} = e^{-γ|x-y|} / 4π|x-y|$</span> and  <span>$τ(y)$</span> contrast function and <span>$n̂(x)$</span> normal vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/volumeintegral/vie.jl#L263-L276">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.VIE.hhvolume-Tuple{}"><a class="docstring-binding" href="#BEAST.VIE.hhvolume-Tuple{}"><code>BEAST.VIE.hhvolume</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hhvolume(;gamma, alpha, tau)
hhvolume(;wavenumber, alpha, tau)</code></pre><p>Bilinear form given by:</p><p class="math-container">\[    α ∬_{Ω×Ω} (grad j(x)) ⋅ G_{γ}(x,y)τ(y) (grad k(y))\]</p><p>with <span>$G_{γ} = e^{-γ|x-y|} / 4π|x-y|$</span> and  <span>$τ(y)$</span> contrast function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/volumeintegral/vie.jl#L219-L231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.VIE.hhvolumegradG-Tuple{}"><a class="docstring-binding" href="#BEAST.VIE.hhvolumegradG-Tuple{}"><code>BEAST.VIE.hhvolumegradG</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hhvolumegradG(;gamma, alpha, tau)
hhvolumegradG(;wavenumber, alpha, tau)</code></pre><p>Bilinear form given by:</p><p class="math-container">\[    α ∬_{Ω×Ω} j(x) grad_y(G_{γ}(x,y)) τ(y) ⋅ (grad k(y))\]</p><p>with <span>$G_{γ} = e^{-γ|x-y|} / 4π|x-y|$</span> and  <span>$τ(y)$</span> constant function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/volumeintegral/vie.jl#L353-L365">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.VIE.hhvolumek0-Tuple{}"><a class="docstring-binding" href="#BEAST.VIE.hhvolumek0-Tuple{}"><code>BEAST.VIE.hhvolumek0</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>hhvolumek0(;gamma, alpha, tau) hhvolumek0(;wavenumber, alpha, tau)</p><p>Bilinear form given by:</p><p class="math-container">\[    α ∬_{Ω×Ω} j(x) G_{γ}(x,y)τ(y) k(y)\]</p><p>with <span>$G_{γ} = e^{-γ|x-y|} / 4π|x-y|$</span> and  <span>$τ(y)$</span> contrast function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/volumeintegral/vie.jl#L308-L320">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.Maxwell3D.doublelayer-Tuple{}"><a class="docstring-binding" href="#BEAST.Maxwell3D.doublelayer-Tuple{}"><code>BEAST.Maxwell3D.doublelayer</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">doublelayer(;gamma)
doublelayer(;wavenumber)</code></pre><p>Maxwell double layer operator.</p><p>Either gamma or the wavenumber must be provided. Optionally, also alpha can be provided.</p><p>If alpha is not provided explitly, it is set to <span>$α = 1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/maxwell.jl#L53-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.Maxwell3D.hypersingular-Tuple{}"><a class="docstring-binding" href="#BEAST.Maxwell3D.hypersingular-Tuple{}"><code>BEAST.Maxwell3D.hypersingular</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hypersingular(;wavenumber)</code></pre><p>Hyper singular part of the Maxwell 3D single layer operator.</p><p><span>$β = -1/\mathrm{j} k$</span> is set with the wavenumber <span>$k$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/maxwell.jl#L44-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.Maxwell3D.planewave-Tuple{}"><a class="docstring-binding" href="#BEAST.Maxwell3D.planewave-Tuple{}"><code>BEAST.Maxwell3D.planewave</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">planewave(;
        direction    = error(&quot;missing arguement `direction`&quot;),
        polarization = error(&quot;missing arguement `polarization`&quot;),
        wavenumber   = error(&quot;missing arguement `wavenumber`&quot;),
        amplitude    = one(real(typeof(wavenumber))))</code></pre><p>Time-harmonic plane wave.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/maxwell.jl#L81-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.Maxwell3D.singlelayer-Tuple{}"><a class="docstring-binding" href="#BEAST.Maxwell3D.singlelayer-Tuple{}"><code>BEAST.Maxwell3D.singlelayer</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">singlelayer(;gamma, alpha, beta)
singlelayer(;wavenumber, alpha, beta)</code></pre><p>Maxwell 3D single layer operator.</p><p>Either gamma, or the wavenumber, or α and β must be provided.</p><p>If α and β are not provided explitly, they are set to <span>$α = -γ$</span> and <span>$β = -1/γ$</span> with <span>$γ=\mathrm{j} k$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/maxwell.jl#L6-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.Maxwell3D.weaklysingular-Tuple{}"><a class="docstring-binding" href="#BEAST.Maxwell3D.weaklysingular-Tuple{}"><code>BEAST.Maxwell3D.weaklysingular</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">weaklysingular(;wavenumber)</code></pre><p>Weakly singular part of the Maxwell 3D single layer operator.</p><p><span>$α = -\mathrm{j} k$</span> is set with the wavenumber <span>$k$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/maxwell/maxwell.jl#L35-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.Variational.HilbertVector-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#BEAST.Variational.HilbertVector-Tuple{Any, Vararg{Any}}"><code>BEAST.Variational.HilbertVector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">call(u::HilbertVector, f, params...)
u(f, params...)</code></pre><p>Add another operation to the opstack of <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/utils/variational.jl#L252-L257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.Variational.depthfirst-Tuple{Any}"><a class="docstring-binding" href="#BEAST.Variational.depthfirst-Tuple{Any}"><code>BEAST.Variational.depthfirst</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">depthfirst(xp)</code></pre><p>Returns an iterator that visits all nodes in an Expr depth first. head and args are visited before the Expr they define.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/utils/variational.jl#L20-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.Variational.transposecalls!"><a class="docstring-binding" href="#BEAST.Variational.transposecalls!"><code>BEAST.Variational.transposecalls!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transposecall!(xp, skip=[])</code></pre><p>Goes through the syntax tree and replace all function calls <code>f(p1,p2,...,x)</code> with <code>x(f,p1,p2,...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/utils/variational.jl#L75-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Tuple{BEAST.Variational.BilForm, BEAST.Variational.BilForm}"><a class="docstring-binding" href="#Base.:+-Tuple{BEAST.Variational.BilForm, BEAST.Variational.BilForm}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Add two BilForms together</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/utils/variational.jl#L343">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Tuple{BEAST.Variational.BilForm, BEAST.Variational.LinForm}"><a class="docstring-binding" href="#Base.:==-Tuple{BEAST.Variational.BilForm, BEAST.Variational.LinForm}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">==(lhs::BilForm, rhs::LinForm)</code></pre><p>Build an equation from a left hand and right hand side</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/utils/variational.jl#L159-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{Any, BEAST.Variational.HilbertVector, BEAST.Variational.HilbertVector}"><a class="docstring-binding" href="#Base.getindex-Tuple{Any, BEAST.Variational.HilbertVector, BEAST.Variational.HilbertVector}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(A, v::HilbertVector, u::HilbertVector)</code></pre><p>Create a BilForm corresponding to A[v,u]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/utils/variational.jl#L280-L284">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{Any, BEAST.Variational.HilbertVector}"><a class="docstring-binding" href="#Base.getindex-Tuple{Any, BEAST.Variational.HilbertVector}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(f, v::HilbertVector)
f[v]</code></pre><p>Return a LinForm corresponding to f[v]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/utils/variational.jl#L263-L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BEAST.Variational.@varform-Tuple{Any}"><a class="docstring-binding" href="#BEAST.Variational.@varform-Tuple{Any}"><code>BEAST.Variational.@varform</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@varform &lt;form-definition&gt;</code></pre><p>The Julia form compiler uses the Julia parser and meta-programming based traversal of the AST to create a structure containing all information required for the description of a variational formulation from an Expr that follows closely widespread mathematical convention.</p><p>E.g:</p><pre><code class="language-julia hljs">EFIE = @varform T[k,j] = e[k]
MFIE = @varform 0.5*I[k,j] + K[k,j] = h[k]
PMCH = @varform M[k,j] - η*T[k,m] + 1/η*T[l,j] + M[l,m] = e[k] + h[l]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/krcools/BEAST.jl/blob/55ec0a3b8cc98ff7b60cef65eed15c91e531e1ac/src/utils/variational.jl#L422-L435">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../references/">« References</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 10 January 2026 15:14">Saturday 10 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
